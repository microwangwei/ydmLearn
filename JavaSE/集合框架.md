# 集合详解

## 1.集合框架初步了解：

我们经常在想集合是什么?什么是集合?Java是一门面向对象的语言，就免不了处理对象，为了方便操作多个对象，那么我们就得把这多个对象存储起来，想要存储多个对象(变量),很容易就能想到一个容器(集合)来装载,简单来说集合就是"由若干个确定的元素所构成的整体",

集合的特点:

1. 集合只能存放对象。比如你存入一个int型数据66放入集合中，其实它是自动转换成Integer类后存入的,JAVA中每一种基本数据类型都有对应的引用类型。
2. 集合存放的都是对象的引用，而非对象本身。所以我们称集合中的对象就是集合中对象的引用。对象本身还是存放堆内存中
3. 集合可以存放不同类型，不限数量的数据类型

集合与数组的区别:

1. 数组是固定长度的;集合可变长度的
2. 数组可以存储基本数据类型,也可以存储引用数据类型;集合只能存储引用数据类型
3. 数组存储的元素必须是同一个数据类型;集合存储的对象可以是不同的数据类型.(加了泛型就不一样了)

Java集合框架图：

![image-20210813201208898](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210813201208898.png)

Java集合框架可以分为两条大的支线:

- Collection:
  - 主要是由List、Set、Queue组成。
    - List代表有序、可重复的集合，典型代表就是封装了动态数组的ArrayList和封装了链表的LinkedList;
    - Set代表无序、不可重复的集合，典型代表就是HashSet和TreeSet；
    - Queue代表队列，典型代表就是双端队列ArrayDeque，以及优先级队列PriorityQue;
- Map:
  - 代表键值对的集合,典型代表就是HashMap

常用集合归纳:

1. List接口:元素按进入先后有序保存，可重复

   - `LinkedList` 接口实现类， 链表， 插入删除， 没有同步， 线程不安全
   - `ArrayList` 接口实现类， 数组， 随机访问， 没有同步， 线程不安全
   - `Vector` 接口实现类 数组， 同步， 线程安全（Stack 是Vector类的实现类）

2. Set接口:仅接收一次，不可重复，并做内部排序

   - `HashSet` 使用hash表（数组）存储元素
   - `LinkedHashSet` 链表维护元素的插入次序
   - `TreeSet` 底层实现为二叉树，元素排好序

    

直接上图(这里是单列集合,双列是Map):

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-7f402ef358817499ad276455ef470e6e_720w.jpg)

## 2. Collection 使用和常用方法

Collection接口是处理对象集合的根接口，其中定义了很多对元素进行操作的方法。Collection接口有两个主要的子接口List和Set，**注意Map不是Collection的子接口，这个要牢记。**

常用方法:

1. 添加功能 boolean `add`(E e) 添加一个元素 boolean `addAll`(Collection c)添加一批元素
2. 删除功能 boolean `remove`(Object o) 删除一个元素

3. 判断功能 boolean `contains`(Object o) 判断集合是否包含指定的元素 
4. boolean `isEmpty`()判断集合是否为空(集合中没有元素)
5. 获取功能 int size()
6. 转换功能 Object[] `toArray()` 把集合转换为数组
7. `iterator()`返回一个Iterator接口我们通过Iterator迭代器来遍历集合。

单列集合继承关系图:

![单列集合](https://gitee.com/miawei/pic-go-img/raw/master/imgs/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTklOUIlODYlRTUlOTAlODglRTYlQTElODYlRTYlOUUlQjYvY29sbGVjdGlvbi5wbmc)

### 2.1 List

**概念:**list集合代表一个**有序集合**,集合中每个元素都有对应的顺序索引,List集合允许使用**重复元素**,可以通过**索引**来访问指定位置的集合元素

List接口继承于Collection接口，它可以定义一个允许重复的有序集合。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。

![List常用方法](https://gitee.com/miawei/pic-go-img/raw/master/imgs/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTklOUIlODYlRTUlOTAlODglRTYlQTElODYlRTYlOUUlQjYvTGlzdCVFNSVCOCVCOCVFNyU5NCVBOCVFNiU5NiVCOSVFNiVCMyU5NS5wbmc)

#### 2.1.1 ArrayList

**概念:**ArrayList其本质说起来是一个**动态数组**(在实际开发也比较常用)

**特点:**

1. 允许符合规则的元素插入甚至包括null

2. 每一个`ArrayList`都有一个初始容量(10),该容量代表了数组大小,随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以**如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。**在创建的时候是创建了一个空数组,在add的时候才会去初始容量

   扩容机制:每次扩容1.5倍.

   ```java
    private static final int DEFAULT_CAPACITY = 10;
   ```

3. 非线程安全，异步

4. 查询和修改比较快,添加和删除相对比较慢,这是因为底层实现的是数组,遍历时很快,但是插入或者删除时都需要移动后面的元素,所以效率略差

5. 基于动态数组的数据结构,底层是Object类型的数组

6. 插入的元素是有序的

如:

```java
ArrayList bag = new ArrayList();
bag.add("电脑");
bag.add(200);
bag.add("鼠标");
bag.add("小人书");
bag.add("教材");
bag.add("牛奶");
		
for(int i=0;i<bag.size();i++){ 
	System.out.println(bag.get(i));
} //这是普通for循环,也可以foreach循环
```

说明:ArrayList与java中的数组最大区别就在于ArrayList能够动态扩容,但ArrayList不是线程安全只能用于单线程的环境中,所以效率较高

那如果要安全怎么办?

多线程可以使用 **Collections.synchronizedList(List list)** 函数返回一个线程安全的 ArrayList 集合，或者使用 concurrent 并发包下的CopyOnWriteArrayList，如下：

```java
//使用Collections.synchronizedList(List list)方法实现线程安全
List<?> list = Collections.synchronizedList(new ArrayList<>());
```



#### 2.1.2 LinkedList

**概念:**内部是基于链表(双向链表)结构实现的,添加和删除较快,但是查询相对于ArrayList较慢

因为实现了Quere接口,所以可以当队列和栈来处理,但是同时继承实现了list和quere,所以就充满了list的方法和quere的方法出现重复,在写的时候如果使用list那么就可能就用list的方法,因为这样才是体现集合特性

比如:pop()和push(),就可以当做栈来使用,前者用于从堆栈中弹出一个元素,后者表示压入栈中

**特点:**

1. 内部相对于ArrayList而言多了一些操作头和尾的方法
2. 可以充当队列，堆栈(是因为是基于双向链表所以可以充当)
3. 不是线程安全的（同步的)
4. 运行null元素

如:

```java
	LinkedList linkedList = new LinkedList();
    linkedList.add("12");
    linkedList.addFirst(1);
    linkedList.addLast(3);
//采用foreach循环
    for (Object e : linkedList) {
      System.out.println("e = " + e);
    }
//采用for普通循环
    for (int i = 0; i < linkedList.size(); i++) {
      System.out.println(linkedList.get(i));
    }
```

**注意:**LinkedList底层通过双向链表实现，双向链表的每个节点用内部类Node表示。LinkedList通过first和last引用分别指向链表的第一个和最后一个元素。**在这里没有所谓的哑元，当链表为空的时候first和last都指向null。**

```java
transient int size = 0;

/**
 * Pointer to first node.
 */
transient Node<E> first;

/**
 * Pointer to last node.
 */
transient Node<E> last;
```

不适合查找慢的原因:

LinkedList 底层基于链表结构，无法向 ArrayList 那样随机访问指定位置的元素。LinkedList 查找过程要稍麻烦一些，需要从链表头结点（或尾节点）向后查找，时间复杂度为 O(N)。

**LinkedList不擅长随机位置访问，如果使用随机访问遍历LinkedList效率会很差**

总结:

```html
1.LinkedList是基于双向链表实现的，不论是增删改查方法还是队列和栈的实现，都可通过操作结点实现
2.LinkedList无需提前指定容量，因为基于链表操作，集合的容量随着元素的加入自动增加
3.LinkedList删除元素后集合占用的内存自动缩小，无需像ArrayList一样调用trimToSize()方法
4.LinkedList的所有方法没有进行同步，因此它也不是线程安全的，应该避免在多线程环境下使用
```



#### 2.1.3 Vector

与ArrayList相似，但是Vector是同步的。所以说**Vector是线程安全的动态数组**。它的操作与ArrayList几乎一样。

Vector是一个元老级别的类,比ArrayList出现得还要早,在Vector内部像get、add、set这些方法都加了`synchronized`关键字,就会导致执行效率会比较低,所以现在基本上对于线程安全的list不会用它了,更好的选择就是:

```java
选择并发包下的CopyOnWriteArrayList
```

但是有区别:ArrayList是线程不安全的而效率较低,其他都一样

#### 2.1.4 Stack

Stcak是Vector的一个子类,本质上也是由动态数组实现的,只不过还实现了先进后出的功能(在get、set、add方法的基础上追加了pop、peek等方法),所以叫栈

**注意:**值得注意的是由于Stack执行效率比较低(方法上同样加了synchronized关键字),就被双端队列ArrayDeque取代了。

#### 2.1.5 区别:

1. `ArrayList`：底层数据结构是数组，查询快，增删慢，线程不安全，效率高，可以存储重复元素
2. `LinkedList` 底层数据结构是链表，查询慢，增删快，线程不安全，效率高，可以存储重复元素
3. `Vector`:底层数据结构是数组，查询快，增删慢，线程安全，效率低，可以存储重复元素

直接看图说话:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-89cebb489a429b2e6f2fc303505ea30d_720w.jpg)

### 2.2 Set

Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个。由于Set接口的特殊性，**所有传入Set集合中的元素都必须不同**，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致`e1.equals(e2)==true`，则必定会产生某些问题。

**注意:**虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的`HashCode`决定的，其具体位置其实是固定的。

Set有一个显著的特点:[无序](无序是指添加数据的顺序与取出数据的顺序不一定是一致的)且不重复

Set中的HashSet、TreeSet、LinkedHashSet都是线程不安全的，可通过Collections.synchronizedSet()返回一个线程安全的Set

![Set常用方法](https://gitee.com/miawei/pic-go-img/raw/master/imgs/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTklOUIlODYlRTUlOTAlODglRTYlQTElODYlRTYlOUUlQjYvU2V0JUU1JUI4JUI4JUU3JTk0JUE4JUU2JTk2JUI5JUU2JUIzJTk1LnBuZw)

在set接口中的不重复是有特殊要求:

比如:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了`hashcode`和`equals`方法，并且重写后的`hashcode`和`equals`方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和`hashcode`与`equals`方法直接相关。

**理解:**

1. 通过添加进去的元素的`hashCode`+`eqauls`  两者进行比较
2. 如果两个对象的`hashCode`相等  并且 两个对象调用equals结果是true  才认为两个元素重复

#### 2.2.1 HashSet

HashSet 是一个**没有重复元素**的集合。它是由`HashMap`实现的，不保证元素的顺序(这里所说的没有顺序是指：元素插入的顺序与输出的顺序不一致)，而且HashSet允许使用null 元素。HashSet是非同步的，如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。 **HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。**

**实现方式:**通过一个`HashMap`存储元素，元素是存放在`HashMap`的Key中，而Value统一使用一个Object对象。

**特点:**

1. 它不允许出现重复元素；
2. 不保证集合中元素的顺序(看起来是无序的其实底层是通过hashCode计算存储位置的)
3. 允许包含值为null的元素，但最多只能有一个null元素。
4. `HashSet`的实现是不同步的。如果多线程操作`HashSet`集合，则应通过代码来保证其同步
5. 底层数据结构是**哈希表**(数组+链表+[红黑树](jdk1.8出来的)的结构)

简单例子:

```java
public static void main(String[] args) {
  HashSet set = new HashSet();
  set.add(null);
  set.add(null);
  for (Object o : set) {
    System.out.println("o = " + o);
  }
}
结果:
o = null
```

总结:

1. HashSet底层是HashMap,并且HashMap中的set相当于在HashMap的key,而value则是`new Object`出来的常量,而扩容条件则是按照hashMap的扩容规则去扩容的

```java
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable {
    static final long serialVersionUID = -5024744406713321676L;

    private transient HashMap<E,Object> map;  //底层采用HashMap进行存储

    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();  //作为HashMap中的value常量，而key则是真正set要存的数据

    /**
     * Constructs a new, empty set; the backing {@code HashMap} instance has
     * default initial capacity (16) and load factor (0.75).
     */
    public HashSet() {
        map = new HashMap<>(); //直接创建一个HashMap
    }
```

2. HashSet其实就是一个在某种场景下，催化出来的一个数据结构，几乎没有自己的实现，都是借助HashMap 来实现了种种功能

3. 在add的时候底层是会调用HashMap的put方法,然后对传进来的key进行计算[哈希值](哈希值是JDK根据对象的地址或者字符串或者数字计算出来的int类型的数值（object类中有一个方法可以获取对象的哈希值）),HashSet的唯一性则是通过重写**hashCode()**方法和**equal()**方法实现的

   ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20200817231824763.png)

4.HashSet:基于HashMap,HashMap基于hashCode,是一个非线程安全。HashMap底层是键值对的数组+单向链表+红黑树（1.8）

5.构造方法:

```java
HashSet()
	构造一个新的空集合;HashMap实例具有默认初始容量(16)和加载因子(0.75)
	16就是键值对数组的长度，负载因子（0，75）指的是当容量达到75%，就会扩容
HashSet(Collection c)
	构造一个包含指定集合中的元素的新集合。
Hashset（int initialCapacity）【建议使用】
	创建 HashMap对象，键值对数组长度是 initialCapacity，标签默认负载因子（0.75)
Hashset（int initialCapacity，f1 oat loadfactor）【不建议用】
	沟造一个新的空集合；背景 HashMap实例具有指定的初始容量和指定的负载因子
```



#### 2.2.2 TreeSet

TreeSet是一个有序集合，其底层是基于TreeMap实现的，非线程安全。TreeSet可以确保集合元素处于排序状态。**TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。**当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。

**注意:**TreeSet集合不是通过**hashcode**和**equals**函数来比较元素的.它是通过compare或者**comparaeTo**函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。

**特点:**

1. 底层数据结构是红黑树(是一个自平衡的二叉树)
2. 保证元素的排序方式（自然排序），实现Comparable接口
3. 不能添加重复元素
4. **不能添加不同类型的元素,否则要报错**

示例:

```java
TreeSet treeSet = new TreeSet();
      treeSet.add("111");
      treeSet.add("333");
      treeSet.add("222");
      treeSet.add("444");
      treeSet.add("111");
      System.out.println(treeSet);
```

结果:

```java
[111, 222, 333, 444]
```

TreeSet的结构（存储原理）分析:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/wps1.jpg)

1. TreeSet内部是按照大小进行排序的，大小有对象与对象之间比较进行决定的
2. 设计TreeSet之前：Java设计了一个接口Comparable接口，其中提供了对象之间比较的方法CompareTo
3. TreeSet会调用对象的CompareTo方法，比较对象，所以我们放入的对象需实现Comparable

自然排序:

**概念:**此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法

相当于就是说每个对象具有自我比较的能力,也称自然排序(默认升序)

在add(对象)的时候,这个对象必须实现Comparable自然排序,比如需要User类实现 Comparable接口，然后<>要写当前类User，重写 compareTo方法

> 在[添加类型](必须是引用类型,而引用类型jdk内部早已实现了Comparable接口重写了compareTo方法了)的时候必须实现了Comparable接口,且必须重写compareTo()方法,其中返回值0:相同的元素,就不会添加了

定制排序:

**概念:**相当于给容器提供了一个裁判,也就是可以这样去理解,原本的容器里的排序规则已然不能适应新的需求,所以现在需要手动建一个排序规则

如何实现:

1. Comparator 是一个比较器的接口（标准），必须得有进行比较的方法 ：compare(Object o1,Object o2);
2. 自定义一个类实现Comparator接口，其中写比较规则  ---> 比较器的模板，我们现在需要的是一个具体的比较器对象

> 在创建TreeSet对象的时候,传入一个Comparator接口的实现类,该实现类必须重写compare方法,其中返回值0:相同的元素

例子:

```java
public class MyComparator implements Comparator{
	@Override
	public int compare(Object o1, Object o2) {
		if(o1==null||o2==null){//判断，若两个有一个为null都直接返回
			return 0;
		}
		if(o1 instanceof Student && o2 instanceof Student){//如果类型匹配才转换
			Student stu1 = (Student)o1;
			Student stu2 = (Student)o2;
			if(stu1.age>stu2.age){//先判断年龄后判断姓名
				return 1;
			}else if(stu1.age<stu2.age){
				return -1;
			}else{
				return stu1.name.compareTo(stu2.name);
			}
		}
		return 0;
	}
}
```

> 注意:当自然排序和定制排序同时使用,定制排序优先级更高。一般情况下，默认排序用自然排序，特殊排序用定制排序

总结:

```html
1.内部实现的是TreeMap
2.其构造方法主要有两个,一个是默认的无参构造方法,一个是比较器构造函数
3.TreeSet是有序的,取决于构造方法->1.自然排序 2.定制器比较函数
4.性能方面要比HashSet差,但如果业务场景需要排序且不重复优先选择TreeSet->默认自然排序(升序)
5.TreeSet只能通过迭代器迭代元素
6.TreeSet是用红黑树来存储数据的
```

#### 2.2.3LinkedHashSet

`LinkedHashSet`继承自`HashSet`，其底层是**基于LinkedHashMap来实现的**，有序，非同步。`LinkedHashSet`集合同样是根据元素的`hashCode`值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，**LinkedHashSet将会以元素的添加顺序访问集合的元素。**

```java
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
   map = new LinkedHashMap<>(initialCapacity, loadFactor);
}
```

总结:

```html
1.LinkedHashSet 是HashSet的子类
2.LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的
3.LinkedHashSet 插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能
4.LinkedHashSet 不允许集合元素重复
5.LinkedHashSet 中维护一个hash表的双向链表 LinkedHashSet有head和tail
```

> 是一个有序的HashSet,在HashSet基础上维护了一个链表结构

#### 2.2.4 各Set实现类的性能分析

1. `HashSet`的性能比`TreeSet`的性能好（特别是添加，查询元素时），因为`TreeSet`需要额外的红黑树算法维护元素的次序，如果需要一个保持排序的Set时才用`TreeSet`，否则应该使用`HashSet`。
2. `LinkedHashSet`是`HashSet`的子类，由于需要链表维护元素的顺序，所以插入和删除操作比`HashSet`要慢，但遍历比`HashSet`快。
3. `EnumSet`是所有Set实现类中性能最好的，但它只能 保存同一个枚举类的枚举值作为集合元素。

共同特点:线程不安全的!

### 2.3 list和set的区别:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-16dbe05c9604ff50d1a75af315a22650_720w.jpg)

### 2.4 Collection:选择技巧:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-02315d96094ad52616c6c44c01e7d319_720w.jpg)

## 3.Map

Map用于保存具有映射关系的数据，Map里保存着两组数据：key和value，它们都可以使任何引用类型的数据，但key不能重复。所以通过指定的key就可以取出对应的value

每个元素有键与值两部分组成,通过键可以找到对应的值

**注意:**Collection中的集合称为单列集合，Map 中的集合称为双列集合。需要注意的是，**Map中的集合不能包含重复的键**，**值可以重复;每个键只能对应一个值。**

双列集合继承关系图:

![双列集合](https://gitee.com/miawei/pic-go-img/raw/master/imgs/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTklOUIlODYlRTUlOTAlODglRTYlQTElODYlRTYlOUUlQjYvbWFwLnBuZw)

map图解:

![preview](https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-dddfb8f8b30a5573fc790902b3cc8ccf_r.jpg)

map主要方法:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-a6a84ee86170bec483c91b1e6d748e30_720w.jpg)

### 3.1 HashMap

以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。并且hashmap是非同步的,并且允许null键或null值

HashMap底层实现原理:

由于我们之前常用的数据结构1.数组 2.链表 都各有优点,而缺点却也异常明显,而还有一种数据结构 **哈希表结构**:**结合数组结构和链表结构的优点，从而实现了查询和修改效率高，插入和删除效率也高的一种数据结构**

> HashMap的数据结构为:键值对数组+单向链表+红黑树; 具体则是键值对数组,其中每一个坑位多个存储多个键值对,默认单向链表,数量超过8个为红黑树,而当少于等于6个就会变为单向链表

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20201218094332663.png)

```
为何随机增删、查询效率都很高的原因是？
原因:增删是在链表上完成的，而查询只需扫描部分，则效率高。
```

HashMap红黑树原理分析:

​	相比 jdk1.7 的 HashMap 而言，jdk1.8最重要的就是引入了红黑树的设计，当hash表的单一链表长度超过 8 个的时候，链表结构就会转为红黑树结构。这样做的好处就在于避免在最极端的情况下链表变得很长很长,查询的时候就会变得很慢!

​	红黑树查询:其访问性能近似于折半查找,时间复杂度O(logn)

​	链表查询:这种情况下,就需要遍历全部元素才行,时间复杂度O(n)

> 简单的说，红黑树是一种近似平衡的二叉查找树，其主要的优点就是“平衡“，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为 log(n)。

HashMap存数据的过程是:

​	HashMa内部维护了一个存储数据的 Entry数组，HashHap采用链表解决冲突，每一个 Entry本质上是一个单向链表。当准备添加一个key-valve对时，首先通过hash（key）方法计算hash值，然后通过indexFor（hash，length）求该key-value对的存储位置，计算方法是先用hash&0x7 FFFFFFF后，再对 Length取模，这就保证每一个key-valve对都能存入 HashMap中，当计算出的位置相同时，由于存入位置是一个链表，则把这个key-value对插入链表头(jdk1.7是头部,jdk1.8之后都是加入链表后面)

总结:

```
1.HashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。
2.HashMap中key和value都允许为null。key为null的键值对永远都放在以table[0]为头结点的链表中(这是做了特殊处理的)。
3.HashMap内存储数据的Entry数组(键值对数组)默认是16，如果没有对Entry扩容机制的话，当存储的数据一多，Entry内部的链表会很长，这就失去了HashMap的存储意义了。所以HasnMap内部有自己的	扩容机制。默认负载因子是0.75(扩容机制是当容量达到75%的时候,就开始扩容,就是创建新数组,复制元素,这里0.75一般不推荐修改因为经过测试这是最优化的)
4.底层是键值对的数组,而数组里的结构就有单向链表
```

扩容机制:所谓的扩容就是创建新的数组,然后把旧的数组复制到这个新数组中,而复制过来就会重新计算下标,计算方式:key的哈希值跟数组长度的取余,最终取出来的就是新的下标,而扩容大小则是获取数组当前(默认是16)然后扩大2倍,比如16扩大后就是32。而之所以会自动扩容就是会检测键值对数量达到总长度的75%左右就会自动扩容

底层原理:   

![2021年8月6日](https://gitee.com/miawei/pic-go-img/raw/master/imgs/2021%E5%B9%B48%E6%9C%886%E6%97%A5-1628235034525.png)   

```html
在HashMap底层实现的是Entry键值对数组(默认长度16),而数组内部单个项里存储是单向链表结构;
实现put存入原理:
	因为底层是数组而数组存入数据都是通过下标而进行的,所以在put存入的时候首先会对key进行哈希运算获取哈希值,第二步就会去获取该键值对的数组长度,然后进行取模运算,比如目前现在数组长度为16,然后哈希值为18(假如的情况),然后进行取余如18%16=2,那么此时的2就是数组的下标位置(当然在底层不是直接取余的而是进行另一种的位运算),之前在Set中都是获取HashCode来计算位置,其实准确的意义来讲就是获取下标(这里要注意null在hashMap是做了特殊处理的),这样做好处就是性能高效、可以更好的避免哈希冲突,然后将该键值对放进该数组里对应的下标处,然而在存放的过程中如果已经出现有其他的键值对,则发生哈希冲突,那么此时就会用equals进行比较键,此时就有两种情况,第一种情况如果相等,那么我们就可以认为存的就是想同的key值,这时就把已经存在的键值进行覆盖,而如果出现不相等的情况下,我们就可以理解为两者不是相同的key,则将新加入的键值对追加到原键值最后面形成单向链表。但是如果单向链表长度达到8个的时候,则会优化单向链表为红黑树。
	当存入一定容量的时候,hashMap就会进行扩容操作,而hash的加载因子就起了作用,这个加载默认为0.75也就是75%,也可以理解为当添加的键值对个数达到数组总长度的75%的时候，会进行自动扩容，而扩容就会对原数组中所有的键值对复制到新数组中，这时就会重新计算所有的下标，这个计算就是底层的位运算也就是进行重新进行通过哈希值和数组长度进行取余，然后重新计算下标进行存入，当这个操作叫做resize();
而我们进行删除key调用remove方法的时候,如果刚好删除的键值对是红黑树,那么此时就会判断红黑树上键值对个数<=6个的时候,则会重新还原为单向链表,而之所以这样来回切换都是基于效率切换,而红黑树的效率就在于每次找到都是对折查找
```

数组保存数据的方式:单向链表:

![image-20210806155507063](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210806155507063.png)

数组保存数据的方式:红黑树

![image-20210806155427761](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210806155427761.png)


### 3.2 Hashtable

```java
1.Hashtable同样是基于哈希表实现的，同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。
2.Hashtable也是JDK1.0引入的类，是线程安全的，能用于多线程环境中。
3.Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。  
4.虽然线程安全但是效率较低    
5.就是一个线程安全的HashMap，不能存放null键和null值    
```

简介:HashTable是较为远古的使用Hash算法的容器结构了，现在基本已被淘汰，单线程转为使用HashMap，多线程使用ConcurrentHashMap。

操作:HashTable的操作几乎和HashMap一致，主要的区别在于HashTable为了实现多线程安全，在几乎所有的方法上都加上了synchronized锁，而加锁的结果就是HashTable操作的效率十分低下。

### 3.3LinkedHashMap

业务场景:比如一些场景存入和取出都是有序的

LinkedHashMap是HashMap的子类,内部使用链表来记录插入/访问元素的顺序。

LinkedHashMap可以看作HashMap+LinkedList的合体,它使用了哈希表来存储数据,又用了双向链表来维持顺序

就是一个内部维护了一个链表的HashMap，可以保证存入和取出顺序

如:

```java
LinkedHashMap<String, Integer> map = new LinkedHashMap<>();
map.put("星期一", 40);
map.put("星期二", 43);
map.put("星期三", 35);
map.put("星期四", 55);
map.put("星期五", 45);
map.put("星期六", 35);
map.put("星期日", 30);
for (Map.Entry<String, Integer> entry : map.entrySet()){
    System.out.println("key: " + entry.getKey() + ", value: " + entry.getValue());
}

//结果:
key: 星期一, value: 40
key: 星期二, value: 43
key: 星期三, value: 35
key: 星期四, value: 55
key: 星期五, value: 45
key: 星期六, value: 35
key: 星期日, value: 30

```

实现原理:

```html
1.LinkedHashMap 通过特有底层双向链表的支持，使得LinkedHashMap可以保存元素之间的顺序，例如插入顺序或者访问顺序，而HashMap因为没有双向链表的支持，所以就不能保持这种顺序，所以它的访问就是随机的了
2.和HashMap一样，还是通过数组存储元素的
3.这里的顺序指的是遍历的顺序，定义了头结点head，当我们调用迭代器进行遍历时，通过head开始遍历，通过after属性可以不断找到下一个，直到tail尾结点，从而实现顺序性。在同一个hash（其实更准确的说是同一个下标，数组index ,在上图中表现了同一列）链表内部next和HashMap.Node.next 的效果是一样的。不同点在于before和after可以连接不同hash之间的链表，也就是说双向链表是可以跨任何index 连接的，也就是说将LinkedHashMap里面的所有元素按照特定的顺序连接起来的
```

总结:

```java
1.有序性:
	LinkedHashMap 指的是遍历的时候的有序性，而有序性是通过双向链表实现的，真实的存储之间是没有顺序的，和HashMap 一样，接下来LinkedHashMap 就是实现了很多方法来维护这个有序性;
2.LinkedHashMap相对于HashMap，增加了双链表的结果（即节点中增加了前后指针），其他处理逻辑与HashMap一致，同样也没有锁保护，多线程使用存在风险。
```



### 3.4 TreeMap

**TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。**TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。

1. **自然排序**:TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常
2. **定制排序**:定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口

TreeMap判断两个元素相等的标准：两个key通过`compareTo()`方法返回0，则认为这两个key相等。如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的`equals()`方法，TreeMap中判断相等的标准是：两个key通过`equals()`方法返回为true，并且通过`compareTo()`方法比较应该返回为0。

总结:

```
1.TreeMap是有序的！
2.TreeMap底层是红黑树，它方法的时间复杂度都不会太高:log(n)~
3.非同步,想要同步可以使用Collections来进行封装,比如	synchronizedSortedMap(SortedMap<K,V> m)
4.如果在构造方法中传递了Comparator对象，那么就会以Comparator对象的方法进行比较。否则，则使用Comparable的compareTo(T o)方法来比较,也就是key的自然排序进行比较。
5.key不能为null，为null为抛出NullPointException的
6.为了保证顺序,TreeMap的键必须实现Comparable接口或者Comparator接口
```



### 3.5 ConcurrentHashMap

**概念:**功能方面跟hashMap是一样的,但是hash是线程不安全的,这是就引入了ConcurrentHashMap线程

就是一个线程安全且效率更高的的HashMap，理论上是Hashtable的16倍

> 可以认为ConcurrentHasp是hashMap的线程安全版本

实现原理:

​	跟hashMap一样内部实现了"数组+链表+红黑树"的方式来实现

```
如何实现线程安全? 加锁
	在 HashTable 中，是直接在 put 和 get 方法上加上了 synchronized，理论上来说 ConcurrentHashMap 也可以这么做，但是这么做锁的粒度太大，会非常影响并发性能，所以在 ConcurrentHashMap 中并没有采用这么直接简单粗暴的方法，其内部采用了非常精妙的设计，大大减少了锁的竞争，提升了并发性能。
```

​	`ConcurrentHashMap` 中的初始化和 `HashMap` 中一样，而且容量也会调整为 2 的 N 次幂.

不允许key和value为null(理由是会引来并发线程的歧义,因为不确定的放的是null还是其本身就是null)

总结:

```
在整个 ConcurrentHashMap 中，整个思想就是降低锁的粒度，减少锁的竞争，所以采用了大量的分而治之的思想，比如多线程同时进行扩容，以及通过一个数组来实现 size 的计数等。
```



### 3.6 map图解:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-d2d98ae61140a9de6e471ae7bee6bdd9_720w.jpg)

## 4. Iterator 与 ListIterator详解

### 4.1 Iterator

Iterator的定义如下：

```java
public interface Iterator<E> {}
```

Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。【单向迭代器】

常用方法:

```java
boolean hasNext()：判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。
Object next() :返回集合里下一个元素。
void remove()：删除集合里上一次next方法返回的元素。   
```

示例:

```java
public class IteratorExample {
    public static void main(String[] args) {
        ArrayList<String> a = new ArrayList<String>();
        a.add("aaa");
        a.add("bbb");
        a.add("ccc");
        System.out.println("Before iterate : " + a);
        Iterator<String> it = a.iterator();
        while (it.hasNext()) {
            String t = it.next();
            if ("bbb".equals(t)) {
                it.remove();
            }
        }
        System.out.println("After iterate : " + a);
    }
}
//结果:
Before iterate : [aaa, bbb, ccc]
After iterate : [aaa, ccc]
```

特点:

- Iterator只能单向移动。
- `Iterator.remove()`是唯一安全的方式来在迭代过程中修改集合；如果在迭代过程中以任何其它的方式修改了基本集合将会产生未知的行为。而且每调用一次`next()`方法，`remove()`方法只能被调用一次，如果违反这个规则将抛出一个异常。

> 有点像链表,从头往后,每获取下一个元素所在的指针指向了下一个区域

### 4.2  ListIterator

首先`Listiterator`是一个功能更加强大的迭代器，它继承于 Iterator接口,只能用于各种List类型的访问。可以通过调用`listIterator()`方法产生一个指向List开始处的ListIterator, 还可以调用`listIterator(n)`方法创建一个一开始就指向列表索引为n的元素处的ListIterator。

**注意:**这个只有list接口才会有!其他都是没有的

构造方法:

```java
双向迭代器方式：Lis接口中方法
1. listiterator（），获取默认指针在头的双向选代器对象
2. listiterator（int index），获取默认指针在指定的 index处双向迭代器对象
```

ListIterator接口定义如下:

```java
public interface ListIterator<E> extends Iterator<E> {
    boolean hasNext();

    E next();

    boolean hasPrevious(); //判断是否有前一个元素

    E previous(); //获取前一个元素

    int nextIndex(); //获取next后续元素的索引

    int previousIndex(); //获取previous后续元素的索引

    void remove();

    void set(E e); //替换指定元素

    void add(E e); //添加元素

}
```

特点:

1. 双向移动（向前/向后遍历）;【双向迭代器】
2. 产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引.
3. 可以使用`set()`方法替换它访问过的最后一个元素.
4. 可以使用`add()`方法在`next()`方法返回的元素之前或`previous()`方法返回的元素之后插入一个元素.

示例:

```java
public class ListIteratorExample {

    public static void main(String[] args) {
        ArrayList<String> a = new ArrayList<String>();
        a.add("aaa");
        a.add("bbb");
        a.add("ccc");
        System.out.println("Before iterate : " + a);
        ListIterator<String> it = a.listIterator();
        while (it.hasNext()) {
            System.out.println(it.next() + ", " + it.previousIndex() + ", " + it.nextIndex());
        }
        while (it.hasPrevious()) {
            System.out.print(it.previous() + " ");
        }
        System.out.println();
        it = a.listIterator(1);
        while (it.hasNext()) {
            String t = it.next();
            System.out.println(t);
            if ("ccc".equals(t)) {
                it.set("nnn");
            } else {
                it.add("kkk");
            }
        }
        System.out.println("After iterate : " + a);
    }
}
//输出结果:
Before iterate : [aaa, bbb, ccc]
aaa, 0, 1
bbb, 1, 2
ccc, 2, 3
ccc bbb aaa 
bbb
ccc
After iterate : [aaa, bbb, kkk, nnn]
```

> listIterator和Iterator初始化都是指针都是指向首节点

## 5.异同点:

### 5.1 ArrayList和LinkedList

1. `ArrayList`是实现了基于动态数组的数据结构，`LinkedList`基于链表的数据结构。
2. 对于随机访问get和set，`ArrayList`绝对优于`LinkedList`，因为`LinkedList`要移动指针。
3. 对于新增和删除操作add和remove，`LinedList`比较占优势，因为`ArrayList`要移动数据。

这一点要看实际情况的。**若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。**但若是批量随机的插入删除数据，`LinkedList`的速度大大优于`ArrayList`. 因为`ArrayList`每插入一条数据，要移动插入点及之后的所有数据。

### 5.2 HashTable与HashMap

相同点:

1. 都实现了`Map、Cloneable、java.io.Serializable`接口。
2. 都是存储"键值对(key-value)"的散列表，而且都是采用拉链法实现的。

不同点:

```html
1.线程安全:
	HashMap是线程不安全的类,多线程下会造成并发冲突,但在单线程下运行效率较高;
	HshTable是线程安全的类,很多方法都是由synchronized进行修饰,但同时因为枷锁导致并发效率低下,单线程环境下也十分低;
2.插入null:
	HashMap允许有一个键为null,允许多个值为null;
	HashTable不允许键或值为null;
3.容量:
	HashMap底层数组长度必须为2的幂,这样做是为了hash的准备,默认为16;
	HashTable底层数组长度可以为任意值,这就造成了hash算法散射不均匀,容易造成hash冲突,默认为11;
4.Hash映射：
	HashMap的hash算法通过非常规设计，将底层table长度设计为2的幂，使用位与运算代替取模运算，减少运算消耗；
	HashTable的hash算法首先使得hash值小于整型数最大值，再通过取模进行散射运算；
5.扩容机制
	HashMap创建一个为原先2倍的数组，然后对原数组进行遍历以及rehash；
	HashTable扩容将创建一个原长度2倍的数组，再使用头插法将链表进行反序；
6.结构区别：
	HashMap是由数组+链表的结构形成,但在jdk1.8之后链表长度大于8时转化为红黑树;
	HashTable一直都是数组+链表;
7.继承关系
	HashMap继承来自AbstractMap类(jdk1.2引入的map接口的一个实现);
	HashTable继承自Dictionary类(较为陈旧);
8.迭代器:
	HashMap只支持Iterator(迭代器)遍历;
	Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历;
```



### 5.3 HashMap、Hashtable、LinkedHashMap和TreeMap比较

```
1.HashMap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。
2.HashMap最多只允许一条记录的key为Null；允许多条记录的value为Null；
3.HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap；可能会导致数据的不一致。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。
4.Hashtable 与 HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢。
5.LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情	况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。
6.如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。
7.LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。对于LinkedHashMap而言，它继承	与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。
8.TreeMap实现SortMap接口，内部实现是红黑树。能够把它保存的记录根据key排序，默认是按key值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。	   TreeMap不允许key的值为null。非同步的。
```

1. 一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。
2. TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好.
3. LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。

示例:

```java
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.TreeMap;

public class MapTest {

    public static void main(String[] args) {

        //HashMap
        HashMap<String,String> hashMap = new HashMap();
        hashMap.put("4", "d");
        hashMap.put("3", "c");
        hashMap.put("2", "b");
        hashMap.put("1", "a");

        Iterator<String> iteratorHashMap = hashMap.keySet().iterator();

        System.out.println("HashMap-->");

        while (iteratorHashMap.hasNext()){

            Object key1 = iteratorHashMap.next();
            System.out.println(key1 + "--" + hashMap.get(key1));
        }

        //LinkedHashMap
        LinkedHashMap<String,String> linkedHashMap = new LinkedHashMap();
        linkedHashMap.put("4", "d");
        linkedHashMap.put("3", "c");
        linkedHashMap.put("2", "b");
        linkedHashMap.put("1", "a");

        Iterator<String> iteratorLinkedHashMap = linkedHashMap.keySet().iterator();

        System.out.println("LinkedHashMap-->");

        while (iteratorLinkedHashMap.hasNext()){

            Object key2 = iteratorLinkedHashMap.next();
            System.out.println(key2 + "--" + linkedHashMap.get(key2));
        }

        //TreeMap
        TreeMap<String,String> treeMap = new TreeMap();
        treeMap.put("4", "d");
        treeMap.put("3", "c");
        treeMap.put("2", "b");
        treeMap.put("1", "a");

        Iterator<String> iteratorTreeMap = treeMap.keySet().iterator();

        System.out.println("TreeMap-->");

        while (iteratorTreeMap.hasNext()){

            Object key3 = iteratorTreeMap.next();
            System.out.println(key3 + "--" + treeMap.get(key3));
        }

    }

}
//结果:
HashMap-->
3--c
2--b
1--a
4--d
LinkedHashMap-->
4--d
3--c
2--b
1--a
TreeMap-->
1--a
2--b
3--c
4--d
```

### 5.4 HashSet、LinkedHashSet、TreeSet比较

- Set接口

  set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回 falseset判断两个对象相同不是使用==运算符，而是根据 equals方法。也就是说，只要两个对象用equals方法比较返回tue，Set就不会接受这两个对象。

- HashSet

  特点:1.不能保证元素的排列顺序，顺序有可能发生变化。2.不是同步的。3.集合元素可以是null，但只能放入一个null。

  当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。简单的说，**HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。**

  注意:如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对象通过equals方法比较返回true时，其hashCode也应该相同。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。

- LinkedHashSet

  LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。

  **LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。**

- Treeset

  TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。

  **TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。**

## 6. Map的遍历方式

### 6.1 通过key找value

方法：Set keySet0返回此地图中包含的键的se视图。实现步骤1.使用 keySet0，把Map集合中的所有的key取出来，存入到一个Set集合中
2.遍历set集合，获取到Map集合中的每一个key
3.通过Map集合中的 v get（object key），获取到所有的vaue值，输出

```java
public class MapTest02 {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map. put( "赵丽颖", 168);
        map. put("杨颖" ,165);
        map. put("林志颖" ,155);
        Set<String> Set = map.keySet();//返回的是一个set集合
        for (String key : Set) {
            Integer value = map.get(key);
            System.out.println(key+" "+value);
        }
    }
}
```

### 6.2 使用 Entry对象遍历

- Entry：键值对（key-value）
  **方法:**

- Map接口

- set<Map.Enty<KV>> entrySet0返回此地图中包含的映射的set视图。

- java.util.Interface.Map.Entry<K，V>

- k getKey()返回与此条目相对应的键。

- v getvalue()返回与此条目相对应的值。

使用Map集合中的 entryset()方法，把集合中多个 Entry对象取出来，存储到一个Set集合中遍历Set集合，获取到每一个Enty用Enty中的 getKey()和 Igetvalue()方法获取键和值

```java
public class MapTest03 {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map. put( "赵丽颖", 168);
        map. put("杨颖" ,165);
        map. put("林志颖" ,155);
        Set<Map.Entry<String, Integer>> set = map.entrySet();
        for (Map.Entry<String, Integer> entry : set) {
            System.out.println(entry.getKey()+entry.getValue());
        }
    }
}
```

### 6.3 values()

通过map.values()遍历所有的key,但是不能遍历key,也就是说通过遍历key获取value值

```java
public class SetDemo {
  public static void main(String[] args) {

    Map m = new HashMap();
    m.put("赵丽颖", 168);
    m.put("杨颖", 165);
    m.put("林志颖", 155);
    Collection values = m.values();
    for (Object value : values) {
      System.out.println("value = " + value);
    }
  }
}
//结果
value = 168
value = 165
value = 155
```

### 6.4 迭代器

使用迭代器遍历无论是删除元素都是很安全的

```java
public class SetDemo {
  public static void main(String[] args) {

    Map<String, Integer> m = new HashMap();
    m.put("赵丽颖", 168);
    m.put("杨颖", 165);
    m.put("林志颖", 155);
      Iterator<Map.Entry<String, Integer>> iterator = m.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, Integer> next = iterator.next();
      System.out.println(next.getKey() + " : "+next.getValue());
    }
  }
}
```

### 6.5结论:

1. 一般来讲使用entrySet的方式进行遍历是效率最高的，因为hashMap内部的存储结构就是基于Entry的数组，在用这种方式进行遍历时，只需要遍历一次即可。而使用其他方式的时间复杂度可以会提高，例如：keySet方式，每次都需要通过key值去计算对应的hash,然后再通过hash获取对应的结果值，因此效率较低。
2. 如果只是获取key，或者value，推荐使用keySet或者values方式
3. 如果同时需要key和value推荐使用entrySet
4. 如果需要在遍历过程中删除元素推荐使用Iterator

## 7.Map特点及使用场景选择

场景:

1. HashMap中key的值没有顺序，常用来做统计。
2. LinkedHashMap它内部维护了一个链表，保持Key插入的顺序。迭代的时候，也是按照插入顺序迭代。
3. TreeMap的顺序是Key的自然顺序（如整数从小到大，默认是按键值的升序排序），也可以指定比较函数。但不是插入的顺序。Comparator  也不支持null键，支持null的value
4. Hashtable与 HashMap类似,它继承自Dictionary类、不同的是:它不允许记录的键或者值为null;它支持线程的同步、即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。

> LinkedHashMap在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会 比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和值无关，而HashMap的遍历速度和他的容量有关

选择:

​	一般情况下我们选用HashMap，因为HashMap的键值对在取出时是随机的，其依据键的hashCode和键的equals方法存取数据，具有很快的访问速度，所以在Map中插入、删除及索引元素时其是效率最高的实现。而TreeMap的键值对在取出时是排过序的，所以效率会低点

1. Map中，HashMap具有超高的访问速度，如果我们只是在Map 中插入、删除和定位元素，而无关线程安全或者同步问题，HashMap 是最好的选择
2. 如果考虑线程安全或者写入速度的话，可以使用HashTable，JDK8后建议使用ConcurrentHashMap替代HashTable,既能获取超高的访问速度，又能保证线程安全
3. 如果想按怎么存的顺序怎么取，比如队列形式，排队，那么使用LinkedHashMap
4. 如果需要让Map按照key进行升序或者降序排序，那就用TreeMap

## 8.Properties集合

**概念**:Properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存属性集。不过Properties有特殊的地方，就是它的键和值都是**字符串类型**。资源文件也可以看成是配置文件,一般的形式有两种:properties形式和XML形式

**说明:**properties文件中的数据的存储是以键值对的形式存在,每一行为一条数据,只能存储字符串形式的数据,Properties文件中的值部分任意字符都会被当做值的一部分,尤其是空格

**作用:**解决硬编码问题【代码逻辑中写死的代码】

常用方法:

1. `getProperty(String key,String defaultValue)`，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。如果得不到那么就会获取默认值
2. `load (InputStream inStream)`，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty (String key) 来搜索。简单理解为从磁盘文件读取出来
3. `setProperty (String key, String value)` ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。
4. `store ( OutputStream out, String comments)`，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。
5. `lear ()`，清除所有装载的 键 - 值对。该方法在基类中提供。
6. `list(PrintStream out)`    简单理解： 此方法可以把Properties中的数据写入磁盘文件

示例:

```java
public class main {
    public static void main(String[] args) {
        method();
    }

    public static void method(){
        Properties prop =new Properties();
        //添加数据
        prop.setProperty("张三", "工程师");
        prop.setProperty("李四", "医生");
        prop.setProperty("王五", "老师");
        
        //获取集合的所有key的集合
        Set<String> keysets = prop.stringPropertyNames();
        for (String s : keysets) {
            String v = prop.getProperty(s);
            System.out.println(s+"="+v);
        }
    }
}
```

- list: 写入硬盘

```java

Properties pp = new Properties();
pp.setProperty("XXXX", "OOOO");
pp.setProperty("YYYY", "JJJJ");
PrintStream ps = new PrintStream("F:/qq.txt");
pp.list(ps);
```

- store:持久化写入硬盘

```java
public class main {
    public static void main(String[] args) throws IOException {
        method();
    }

    public static void method() throws IOException {
        //step1 先创建一个properties对象
        Properties prop =new Properties();
        prop.setProperty("张三", "工程师");
        prop.setProperty("李四", "医生");
        prop.setProperty("王五", "老师");

        //step2 创建一个输出对象
        FileWriter fw = new FileWriter("prop.txt");

        //step3 把数据写入硬盘
        prop.store(fw,"save data");

        //step4 释放资源
        fw.close();
    }
}
```

- load:从硬盘文件读

```java
FileInputStream fis = new FileInputStream("D:/eclipse-jee-juno-SR2-win32-x86_64/eclipse/dropins/easyexplore.link")
pp.load(fis);
System.out.println(pp);
		
String property = pp.getProperty("path");
System.out.println(property);
```

> 这里load有区别:

- void load(InputStream inst)——字节输入，不能读取中文
- void loac(Reader r)——字符输入，可以读取中文,比如 prop.load(new FileReader("prop.txt"));



### 9.1 资源文件解析

针对资源文件的解析，存在三种方式:

1. 传统IO方式;
2. 字节码对象获取流;
3. 类加载器获取流

以上的方式都集中在流的获取上

1. 传统的IO方式:

   ```java
   Properties properties = new Properties();
   properties.load(new FileInputStream(文件路径));
   ```

2. 字节码对象获取流

   什么是字节码对象:字节码对象方式获取流，文件最终必须被编译到class文件存放的位置

   **规则:**字节码对象获取流参数的规则：前必须带/，若资源文件没有在包中，包的路径可以省略

   /:如果是source文件夹，直接写文件名，如果是普通文件夹写文件夹名/文件名

   ```java
   类名.class.getResourceAsStream(/文件路径/文件名)
   ```

3. 类加载器获取流

   什么是类加载器？通过类加载器获取流，那么首要是获取到类加载器，获取类加载器的方式有很多种，以下介绍两种:

   - 字节码对象方式获取类加载器

   ```java
   字节码对象.getClassLoader()
   ```

   - 线程方式获取类加载器

     线程方式获取类加载器稍微比字节码对象获取类加载器稍显复杂，必须先获取当前线程，通过当前线	程获取类加载器

   ```java
   Thread.currentThread().getContextClassLoader()
   ```

获取流的语法:

```java
类加载器对象.getResourceAsStream(包名/文件名)//类加载器获取流的时候，路径最前方不需要书写/
```

例子:

1. 传统方式

   ```java
   /** */
     @Test
     public void testParse1() {
       // 创建Properties对象
       Properties properties = new Properties();
       // 自动关流
       try (FileReader fr = new FileReader("src/main/resources/mysql.properties")) {
         // 加载
         properties.load(fr);
         // 读取
         String username = properties.getProperty("username");
         String password = properties.getProperty("password");
         final String format = StrUtil.format("账号:{},密码{}", username, password);
         System.out.println(format);
   
       } catch (IOException e) {
         e.printStackTrace();
       }
     }
   ```

2. 通过当前字节码文件获取流

   ```java
   /** 通过当前字节码文件获取流 */
     @Test
     public void testParse1() {
       // 创建Properties对象
       Properties properties = new Properties();
   
       // 自动关流
       try (InputStream resource = LoadDemo1.class.getResourceAsStream("/mysql.properties"); ) {
         // 加载
         properties.load(resource);
         // 读取
         String username = properties.getProperty("username");
         String password = properties.getProperty("password");
         System.out.println(username + " : " + password);
   
       } catch (IOException e) {
         e.printStackTrace();
       }
     }
   ```

3. 通过类加载器获取流

   ```java
   /** 通过类加载器获取流 */
     @Test
     public void testParse1() {
       // 创建Properties对象
       Properties properties = new Properties();
       // 当前类.class.getClassLoader();//获取当前类加载器
       // 自动关流-文件路径在资源文件夹里,就可以直接写文件名
       try (final InputStream stream = LoadDemo2.class.getClassLoader().getResourceAsStream("mysql.properties")) {
         // 加载
         properties.load(stream);
         // 读取
         String username = properties.getProperty("username");
         String password = properties.getProperty("password");
         System.out.println(username + " : " + password);
   
       } catch (IOException e) {
         e.printStackTrace();
       }
     }
   ```

4. 通过当前线程的类加载获取流

   ```java
   /** 通过当前线程的类加载器获取流 */
     @Test
     public void testParse1() {
       // 创建Properties对象
       Properties properties = new Properties();
       // 当前类.class.getClassLoader();//获取当前类加载器
       // 自动关流-文件路径在资源文件夹里,就可以直接写文件名
       try (final InputStream stream = Thread.currentThread().getContextClassLoader().getResourceAsStream("mysql.properties")) {
         // 加载
         properties.load(stream);
         // 读取
         String username = properties.getProperty("username");
         String password = properties.getProperty("password");
         System.out.println(username + " : " + password);
   
       } catch (IOException e) {
         e.printStackTrace();
       }
     }
   ```

这里我的项目结构:

![image-20210811145848825](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210811145848825.png)

注意:如果是处于资源文件里那么只需要写文件名即可,以后配置文件都要放到项目中的一个或者几个单独的文件夹中，为了好管理。该文件夹类型是source folder类型，资源文件夹

> 建议用当前线程类的加载器方式获取流，线程安全问题

## 9.泛型

**概念:**泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为[泛型类](https://baike.baidu.com/item/泛型类/9038353)、泛型接口、泛型方法。 [Java语言](https://baike.baidu.com/item/Java语言)引入泛型的好处是安全简单。

**理解:**就是在设计类（接口等）的时候，没有给规定具体是什么类型的参数，在实例化或调用的时候再传入具体的类型，告诉编译器这是什么类型。

**注意:**

1. 泛型不会影响程序的运行的速度，因为在编译期就会直接编译成具体的类型。
2. 使用泛型的方法或实例化泛型的类，只能用传入**引用数据类型**，不能传入基本数据类型

### 9.1 为什么需要泛型:

因为早期的Java是使用Object来代表任意类型的,但是向下转型有强转的问题,这就就会造成程序不安全,如果不用泛型那么在使用Collection集合装载的时候,不对数据类型进行限制,那么传进来的永远是Object,而在get()的时候返回的是Object,而外边获取对象就需要强制类型转换

好处:

1. 代码更加简洁【不用强制转换】
2. 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】
3. 可读性和稳定性【在编写集合的时候，就限定了类型】
4. 在编译的时候检查[类型安全](https://baike.baidu.com/item/类型安全/7308285)，并且所有的[强制转换](https://baike.baidu.com/item/强制转换/4463315)都是自动和[隐式](https://baike.baidu.com/item/隐式/957024)的，以提高代码的重用率。



### 9.2 泛型类:

希望在设计类的时候，其中的数据类型我们就写一个符号，泛指所有的类型，但是不指具体的某种类型,当有人使用我们上面的模板来创建一个对象的时候他们自己可以指定自己的类型

比如:

```java
class Point<数据类型>{    // 表示在类声明了一个符号  数据类型，是一种泛指
   数据类型 x;
   数据类型 y;
} 
```

规范的写法应该是使用一些字母(常见的字母):

​	E 	Element  	元素

​	T	 Type		 类型

​	K	 key		  键

​	V	 value		值

​	?				  任意类型(谁也不知道)

其中k和v应用较多的是:Map<K,V>

```java
public interface Map<K, V> {...}
```

如果子类继承这个父类也叫做泛型类派生出来的子类

要注意以下几点:

1. 实现类的要是重写父类的方法，返回值的类型是要和父类一样的！
2. 类上声明的泛形只对非静态成员有效



### 9.3 泛型方法:

1. 就是把泛型类型的声明放在某个方法上面，只需将泛型参数列表置于返回值前；只能够本方法上或者内部可以使用这个符号；
2. 泛型类，声明的泛型类型可以使用到整个类的
3. 泛型方法来说，是再调用方法的时候传入的实际参数为真实的类型

定义泛型方法...泛型是先定义后使用的

```java
//定义泛型方法..
public <T> void show(T t) {
        System.out.println(t);

    }
```

测试:

```java
public static void main(String[] args) {
        //创建对象
        ObjectTool tool = new ObjectTool();

        //调用方法,传入的参数是什么类型,返回值就是什么类型
        tool.show("hello");
        tool.show(12);
        tool.show(12.5);

    }
```



### 9.4 泛型的上限和下限:

？号通配符表示可以匹配任意类型，任意的Java类都可以匹配【？extends Object】

​	? extends Number :表示表示通配符 ?的[上限],必须是Number及Number的子类

​	? super   Number :表示通配符 ?的[下限],必须是Number及Number的父类

比如:

```java
public static void main(String[] args) {
		ArrayList<Object> lsit1 = new ArrayList<>();
		ArrayList<Number> lsit2 = new ArrayList<>();
		ArrayList<Integer> lsit3 = new ArrayList<>();
		ArrayList<Double> lsit4 = new ArrayList<>();
		ArrayList<String> lsit5 = new ArrayList<>();
		
		//get1(lsit1);//<?  extends Number>:最高可以传入的类型是Number及其子类类型
		//get2(list2);//<?  super Number> :最低可以传入本类类型Number及其父类类型

	}
public static void get1(ArrayList<? extends Number> list){}
public static void get2(ArrayList<? super Number> list){}
```



### 9.5 总结:

1. 限制泛型
   - <T extends Collection>这里的限定使用[关键字](https://baike.baidu.com/item/关键字)extends，后面可以是类也可以是接口。但这里的extends已经不是继承的含义了，应该理解为T类型是实现Collection接口的类型，或者T是继承了XX类的类型。
   - <T extends SomeClass & interface1 & interface2 & interface3>
2. 通配符泛型
   - 如果只指定了<?>，而没有extends，则默认是允许Object及其下的任何Java类了。也就是任意类。
   - [通配符](https://baike.baidu.com/item/通配符)泛型不单可以向上限制，如<? extends Collection>，还可以向下限制，如<? super Double>，表示类型只能接受Double及其上层父类类型，如Number、Object类型的实例。
   - [泛型类](https://baike.baidu.com/item/泛型类)定义可以有多个泛型参数，中间用逗号隔开，还可以定义泛型接口，泛型方法。这些都与泛型类中泛型的使用规则类似

