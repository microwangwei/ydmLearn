# 数据结构

## 1.定时任务

### 1.1 Timer

Timer用于在后台线程中为将来执行任务调度任务的工具类，任务可以被调度执行次、或者定期执行重复执行。

底层可能是线程,可以设置为守护线程

这是Timer的常用方法简析:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20181229092541640)

示例:

```java
public static void main(String[] args) {
  Timer timer = new Timer(); // 创建定时器
  MyTimerTask timerTask = new MyTimerTask(); // 创建定时任务
  timer.schedule(timerTask, 5000); // 执行
}

static class MyTimerTask extends TimerTask {
  @Override
  public void run() {
    System.out.println("我要爆炸了!!!!");
  }
}
```

### 1.2 schedule和scheduleAtFixedRate方法的区别

这两个方法都是任务调度方法，他们之间区别是，schedule会保证任务的间隔是按照定义的period参数严格执行的，如果某一次调度时间比较长，那么后面的时间会顺延，保证调度间隔都是period,而scheduleAtFixedRate是严格按照调度时间来的，如果某次调度时间太长了，那么会通过缩短间隔的方式保证下一次调度在预定时间执行。举个栗子：你每个3秒调度一次，那么正常就是0,3,6,9s这样的时间，如果第二次调度花了2s的时间，如果是schedule，就会变成0,3+2,8,11这样的时间，保证间隔，而scheduleAtFixedRate就会变成0,3+2,6,9，**压缩间隔**，保证调度时间

**理解:**从字面上意思来讲,其中的

### 1.3 缺陷:

1. 由于执行任务的线程只有一个，所以如果某个任务的执行时间过长，那么将破坏其他任务的定时精确性。如一个任务每1秒执行一次，而另一个任务执行一次需要5秒，那么如果是固定速率的任务，那么会在5秒这个任务执行完成后连续执行5次，而固定延迟的任务将丢失4次执行。
2. 如果执行某个任务过程中抛出了异常，那么执行线程将会终止，导致Timer中的其他任务也不能再执行
3. Timer使用的是**绝对时间**，即是某个时间点，所以它执行依赖系统的时间，如果系统时间修改了的话，将导致任务可能不会被执行

## 2.数据结构

**概念:**数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。

**理解:**数据机构又称Data structure,是一种存储数据的结构体,数据与数据存在着一定的关系,这样的关系有数据的逻辑关系、数据的存储关系和数据的运算关系

精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。

数据结构:保存数据的一种方式,根据方式的不同,分为不同的数据结构。

- java中底层所有数据结构都是基于变量和数组的
- 数据相关的操作主要是:增删改查
- 不同的数据结构增删改查效率不同,有些适合增、删、插，有些适合改、查

数据结构的基本功能:

1. 如何插入一条新的数据项
2. 如何寻找某一特定的数据项
3. 如何删除某一特定的数据项
4. 如何迭代的访问各个数据项.以便于显示或其他操作

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/1120165-20171124224517593-271461566.png)

> 数据结构一般可以分为两大类:线性数据结构和非线性数据结构

### 2.1 线性结构

**概念**:线性表是最常用且最简单的一种数据结构，它是n个数据元素的**有限序列**。

**实现:**

1. 使用**数组**存储线性表的元素，即用一组**连续**的存储单元依次存储线性表的数据元素。
2. 使用**链表**存储线性表的元素，即用一组**任意**的存储单元存储线性表的数据元素

> 存储单元可以是连续的也可以是不连续的

#### 2.1.1数组

数组是一种大小固定的数据结构，对线性表的所有操作都可以通过数组来实现。虽然数组一旦创建之后，它的大小就无法改变了，但是当数组不能再存储线性表中的新元素时，我们可以创建一个新的大的数组来替换当前数组。这样就可以使用数组实现动态的数据结构。

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/f9dcd100baa1cd111983dc744cc702fac2ce2d8d.jpeg)

**优点:**

1. 查询速度快(根据索引能够快速访问指定位置的元素)

**缺点:**

1. 插入和删除效率较慢(如插入元素,那就首先就要把所有元素都得往后移一个位置)

来继续往后来看看这个缺点是具体是什么?

假设现在有个ArrayList.因为其内部就是数组构成的,然后准备在第4个位置(下标为3)上添加一个元素55。

![image-20210813205713937](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210813205713937.png)

此时 ArrayList 中第 5 个位置以后的元素将会向后移动。

![image-20210813205733323](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210813205733323.png)

准备把 23 从 ArrayList 中移除

![image-20210813205752156](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210813205752156.png)

此时下标为 7、8、9 的元素往前挪

![image-20210813205815377](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210813205815377.png)

总结一下ArrayList的时间复杂度:

1. 通过下标(也就是`get(int index)`)访问一个元素的时间复杂度为`O(1)`,因为是直达的,无论数据增大多少倍,那么耗时都是不变的
2. 添加一个元素(也就是`add()`)的时间复杂度为`O(1)`,因为直接添加到末尾
3. 删除一个元素的时间复杂度为`O(n)`,因为要遍历列表,数据量增大几倍,耗时也增大几倍。
4. 查找一个未排序的列表时间复杂度为`O(n)`,因为要遍历列表;查找排序过的列表时间复杂度为`O(log n)`,因为可以使用二分查找法,当数据增加N倍时,耗时增加logn倍(这里的log是以2为底的,每找一次排除一半的可能)。

**总结:**总的来说数组在java内存中连续存储线性结构,其中元素类型相同、大小不可发生改变，在使用效率的过程中因为数组是有序数据结构，然后根据索引查询效率快，但是缺点也很明显，必须事先知道数组的长度，在插入和修改删除元素的效率很慢。而每次进行修改都会创建一个新的的数组，这也表明空间是有限制的需要大块连续的内存块。

#### 2.1.2 链表

链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列**节点**组成，这些节点不必在内存中相连。每个节点由数据部分Data和链部分Next，Next指向下一个节点，这样当**添加或者删除时，只需要改变相关节点的Next的指向，效率很高**。

看图一览究竟：

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/2243690-f3fdc61e316abb2b.png)

讲解:

1. head:表示头部
2. tail:表示尾部
3. Data:数据域
4. Next:指针域

**理解:**这里我进行了自我理解,所谓的链表特点就是非连续的结构,不同的节点之间都是通过当前的节点的指针指向下一个节点的地址而去找的。

就好比多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。

**优点：**

1. 空间没有限制
2. 插入删除元素很快

**缺点:**

1. 查找元素慢（因为要查找某个节点那么就要从连接节点依次往后查找指定元素）

直接上代码,理解更深刻:

- 定义节点

```java
public class Node {
    //数据域
    public int data;
    //指针域，指向下一个节点
    public Node next;

    public Node() {
    }
    public Node(int data) {
        this.data = data;
    }
    public Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }
}
```

- 增加节点

```java
/**
 * 向链表添加数据
 * @param value 要添加的数据
 * @param head 头节点
 */
public static void addData(int value, Node head) {
    //初始化要加入的节点
    Node newNode = new Node(value);
    //临时节点
    Node temp = head;
    // 找到尾节点
    while (temp.next != null) {
        temp = temp.next;
    }
    // 已经包括了头节点.next为null的情况了～
    temp.next = newNode;
}
```

- 遍历

```java
// 遍历链表
  public static void traverse(Node node) {
    // 临时节点,从首节点开始
    Node temp = node.next;

    // 打印首节点的数据
    System.out.println("链表首节点: " + node.data);
    while (temp != null) {
      System.out.println("链表数据: " + temp.data);
      // 下一个
      temp = temp.next;
    }
  }
```

- main方法

```java
public static void main(String[] args) {
    // 初始化
    Node node = new Node(1);
    node.next = new Node(3, new Node(5, new Node(8)));
    // 添加
    addDate(9, node);
    // 循环
    traverse(node);
  }
```

结果:

![image-20210801101147494](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210801101147494.png)

**理解:**首先在main方法里创建首节点,然后依次创建子节点,这之间的从上一个节点到下一个的节点关联点就是`Node.next`。

- 然后进行添加一个节点，这时就跳到增加节点的那一环节。先将value值的数据域添加到一个新的节点中，然后链表首节点赋给临时节点，然后就循环while判断下一个节点是否为空，如果不为空那我就可以认定还没到尾结点，对吧，因为尾结点的下一个节点就为没有为空！然后循环把下一个节点放在临时节点上，然后当已经到了尾结点时候就把要加入的节点添加到尾结点的指针域中，这就形成了一个链表结构
- 遍历的话结构上跟添加节点没有区别，就是把下一个节点放在临时节点然后循环判断是否是尾结点，然后把每一个节点中的数据打印出来！

这里我展示一下节点的结构：

![image-20210801102056458](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210801102056458.png)

可以清晰明了可以看出一个节点指向下一个节点地址，

你是不是不知道内存中是如何实现删除和插入的，那么再来看看一张图：

<img src="https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210801102329395.png" alt="image-20210801102329395" style="zoom:80%;" />

可以看出在添加无论是新增还是删除在链表结构中，只是修改了指针域的指向位置！

每个节点包括两部分：

1. 存储数据元素的数据域
2. 存储下一个节点地址的指针域

链表细分分类：

1. 单向链表
   - 一个节点指向下一个节点
2. 双向链表
   - 一个节点有两个指针域,也就是说既知道上一个地址和下一个元素地址都知道。
3. 循环链表
   - 能通过任何一个节点找到其他所有的节点，将两种（单向、双向）链表的最后一个节点指向第一个节点从而实现循环

**总之：**操作链表要时刻记住的是：节点中指针域指向的就是另一个节点！



> 我个人思考过后用大白话来讲：就是一层套一层，就是个套娃

画图理解:

![image-20210803184257174](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210803184257174.png)

在新增的时候,首次进来就放进链表头,然后第二次进来循环找到最后一个,然后放进链表最后一个地址,无图不真相

#### 2.1.3 栈

**概念：**它是运算受限的线性表，其限制是仅允许在栈的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。

其中数组和链表都是线性存储和结构的基础，栈和队列都是线性存储结构的应用。

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/13524038-6edeb2fc6cf1f97f.png)

栈有个显著的特点：

1. 先进后出（存进去的元素，要在后它后面的元素**依次**取出后，才能取出该元素）；
   - 比如：子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。
2. 栈的入口、出口都是栈的栈顶位置

3. 进栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。
4. 出栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。

对于栈来说，**访问**、**插入**和**删除**元素只能在**栈顶**进行,说到栈的特性，有一句经典的言语来概括：**先进后出**，**后进先出。**

其实理解栈的方法也很好记,它就好像一摞盘子,第一个放在最下面,第二个放在第一个上面,第三个放在第二个上面,最后一个放在最上面:

![image-20210813211000434](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210813211000434.png)

------

在java中实现栈:

- 使用数组实现的叫 **静态栈**
- 使用链表实现的叫 **动态栈**

示例:

- 栈

```java
@NoArgsConstructor
@AllArgsConstructor
public class Stack {
    //栈顶
    public Node stackTop;
    //栈底
    public Node stackBottom; //这是Node采用的是链表的结构进行
}
```

- 进栈

```java
// 进栈
  public static void pushStack(Stack stack, int value) {

    // 封装数据成节点
    Node newNode = new Node(value); //创建一个节点

    // 栈顶本来指向的节点交由新节点来指向
    newNode.next = stack.stackTop;  //将栈中的首节点指向新节点的末端

    // 栈顶指针指向新节点
    stack.stackTop = newNode;  //然后将新节点指向了栈的栈顶
  }
//这里就给人感觉就跟装子弹是一样的,先压进来然后再压进来,之前的就在下面去了
//将原本栈顶指向的节点交由新节点来指向，栈顶指向新加入的节点
```

- 遍历栈

```java
// 遍历栈
  public static void traverse(Stack stack) {
    // 获取栈顶的节点
    Node stackTop = stack.stackTop; // 首先获取栈顶的节点

    // 栈顶元素的指针不指向栈顶,那么就会一直输出遍历结果
    while (stackTop != stack.stackBottom) {  //循环判断栈顶是否是栈底,也就是说判断是否是子弹夹里是否存在最后一颗子弹
      System.out.println("栈数据:" + stackTop.data);  //打印数据
      stackTop = stackTop.next;		//将原本栈顶节点的下一个节点又赋给栈顶 
    }
  }
//这里遍历栈更多的是感觉在出栈,因为每次遍历都是将下一个节点的数据装到栈顶
//只要栈顶元素的指针不指向栈底，那么就一直输出遍历结果
```

- 出栈

```java
// 出栈
  public static void popStack(Stack stack) {
    // 栈不为空才能出栈
    if (stack.stackTop != stack.stackBottom) {
      // 栈顶元素
      Node stackTop = stack.stackTop;
      // 栈顶指针指向下一个节点
      stack.stackTop = stackTop.next;
      System.out.println("出栈数据: " + stackTop.data);
    }
  }
//这里的出栈跟遍历栈一个道理,不过这里的出栈只是把栈顶的元素去除了而已
//在出栈之前看看该栈是否为空，不为空才出栈,将栈顶的元素的指针(指向下一个节点)赋值给栈顶指针(完成出栈)
```

- main

```java
public static void main(String[] args) {
    Stack stack = new Stack(); //定义一个栈
    Node tailNode = new Node(9); //首先定义一个初始节点,这个节点作用是栈中首个元素,即指向了栈顶又指向了栈底
    stack.stackTop = new Node(1, new Node(2,tailNode)); //初始化栈
    stack.stackBottom = tailNode;
    // 首先进栈
    pushStack(stack, 4);
    //遍历栈
    traverse(stack);
    //出栈
    popStack(stack);
  }
```

结果:

![image-20210801142231953](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210801142231953.png)

从中我们就可以看出入栈和出栈都是通过栈顶的位置进行改变的,所以总结出栈的特点就是先进后出,

我在学习的过程中遇到一个题,是表示出栈顺序:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/2243690-54461e74300fb358.png)

我先把答案说了，这题选C；我最初在看到这里的时候,运用刚需的栈的特点先进后出嘛,就以为是"6,4,3,2,1"的顺序进栈,那么出栈也应该是"1,2,3,4,6"。可是越想越不对劲，这里选项没有啊！正当我百思不得其解的时候，看过一篇文章瞬间醍醐灌顶；

例子：

```css
一个栈的入栈序列是a,b,c,d,e则栈的不可能的输出序列是：（C）
A edcbd         B decba           C dceab            D abcde
```

首先栈顶的根本-> **后进后出**

初次学习的人或许会认为入栈abcde，所以出栈只能是edcba所以BCD都不对;经过认真分许分段入栈的顺序，也就是说，可能先入栈a，取出a，入栈b，取出b……，所以D也是可能的。知道这个意思了以后，就要明确这个问题的矛盾根本所在：第一次出栈d，说明什么？说明a，b，c一定早已入栈（入栈顺序决定的）。那么在出栈d以后，a，b，c的出栈顺序一定是c，b，a，而不用理会中间穿插着出栈了d后面的字符（因为可以再入栈，再出栈嘛）。所以立即选中**C**，不用犹豫，理由简单：**d出栈了，abc一定已经入栈，那么abc只能以cba的顺序出栈，C不符合**，OK！

看完会回过头来再来看上面的那个题目:从A开始看,首先出栈5,然后根据题目的进栈顺序可以看出,5的后面是6,所以只需要在A中看5后面是否有6,因为既然出栈是5那么我就可以认为5之前的元素都已经出栈了,而我就不用理会5之后的4啊3之类的,因为还可以入栈的嘛,也就是说比如5出栈了,那么现在4可以入栈,然后出栈,然后3可以入栈也可以出栈。再来看B：出栈是4，所以根据题目中的顺序，4后紧跟的是5和6，所以我直接去看4后的顺序是5和6，最主要的是看5是不是在6前面的，因为我不管你5跟6之间穿插了什么，反正5必须在6前面，这样子去判断，所以C中的6在5的前面明显也不符合的嘛，所以就选C

再来举一个例子：

```
如栈顺序是：1 2 3 4 ，如何正确理解出栈？
```

拿4 3 1 2这个出栈序列来说，4最先出来，说明此时1 2 3（底到顶顺序）还都在栈中；接下来只有3能出栈，3出来后，栈中为1 2（底到顶顺序）；再接下来只有2能出栈，所以如果出栈序列前两个是4 3的话，后两个只能是2 1。
再看个正确的出栈序列：2 4 3 1；2最先出来，说明它出来时，3 4还没入栈，而1已入栈且还在栈中；接着是4出来，说明此时3也在栈中（3要比4先入栈），此时栈中有1 3（底到顶顺序）；然后只能3出栈，最后是1出栈。

**总结：**总之，挨个看出栈序列的数据，根据入栈顺序，分析它出来时，栈中应该还有谁，而有谁还没入栈，然后分析此时可不可能是它出栈。

#### 2.1.4 队列

**概念：**队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。

图：

​	![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/13524038-db43b7a2ed8c7148.png)

**理解:**队列,只允许在队尾添加数据,对首移除数据,队列在java中的出现频率非常高,有各种不同类来满足不同的场景需求,像优先级队列PriorityQueue、延时队列DelayQueue等等,队列遵循的就是先进先出

![image-20210813211336214](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210813211336214.png)

**队列的特性：**先进先出、后进后出。

**理解:**可以认为队列就好比在食堂排队打饭的情景,先来的先排着,而后来来的就得乖乖在后面排队,而队头表示最开始来排队的所以对头就可以"打饭",换过来意思就是说出队列可以进行删除操作,而入队列只能插入操作,这样子去想:出队列打了饭就要离开排队队伍去找座位坐下来,而后面的同学依次往上去排

例子:

```java
 public static void main(String[] args) {
    Queue<String> queue = new LinkedList<>();
    queue.offer("A");
    queue.offer("B");
    queue.offer("D");
    queue.offer("E");
    queue.offer("F");
    queue.forEach(System.out::println);

    System.out.println("================================================");
    System.out.println("第一个元素并删除:" + queue.poll());
    queue.forEach(System.out::println);

    System.out.println("================================================");
    System.out.println("返回第一个元素但是不删除:"+queue.element());
    queue.forEach(System.out::println);

    System.out.println("================================================");
    System.out.println("返回第一个元素但是不删除:"+queue.peek());
    queue.forEach(System.out::println);
  }
```

结果:

```java
A
B
D
E
F
================================================
第一个元素并删除:A
B
D
E
F
================================================
返回第一个元素但是不删除:B
B
D
E
F
================================================
返回第一个元素但是不删除:B
B
D
E
F
```

这里的队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。

`LinkedList`类实现了Queue接口，因此我们可以把`LinkedList`当成Queue来用。

区别:

1. **offer，add 区别**

   - 一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。

     这时新的 offer 方法就可以起作用了。它不是对调用 add() 方法抛出一个 unchecked 异常，而只是得到由 offer() 返回的 false。

2. **poll，remove 区别**

   - remove() 和 poll() 方法都是从队列中删除第一个元素。remove() 的行为与 Collection 接口的版本相似， 但是新的 poll() 方法在用空集合调用时不是抛出异常，只是返回 null。因此新的方法更适合容易出现异常条件的情况。

3. **peek，element区别：**

   - element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。

队列中没有元素时，称为**空队列**。

### 2.2 非线性结构

#### 2.2.1 树

首先树是一种典型的非线性结构,它是有n(n>0)个有限节点组成的一个具有层次关系的集合。之所以叫“树”，是因为这种数据结构看起来就像是一个倒挂的树，只不过根在上，叶在下；

树具有以下几个特点：

1. 每个节点都只有有限个子节点或无节点；
2. 没有父节点的根节点称为根节点；
3. 每一个非根节点有且只有一个父节点；
4. 除了根节点外，每个子节点可以分为多个不相交的子树

有关树的图：

![image-20210813212357672](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210813212357672.png)

解释：根节点是第0层，它的子节点是第1层，子节点的子节点是第2层，以此类推

关键术语：

1. 深度：对于任意节点n，n的深度为从根到n的唯一路径长，根的深度为0。
2. 高度: 对于任意节点n,n的高度为从n到一片树叶的最长路径长,所有树叶的高度为0。

##### 2.2.1.1 普通树

树型结构是一类非常重要的非线性数据结构，其中以树和二叉树最为常用,相对于线性的数据结构(链表、数组)而言，树的平均运行时间更短(往往与树相关的排序时间复杂度都不会高)，

普通树对节点是没有任何要求的:

![image-20210813212927646](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210813212927646.png)

##### 2.2.1.2 二叉树

**概念:**二叉树是每个节点最多有两棵子树的树结构。通常子树被称作“左子树”和“右子树”。二叉树常被用于实现二叉查找树和二叉堆。

上图:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/13524038-a3cb5b5857333dff.png)

可以看出每个节点只有1~2个子节点

1. 一棵树至少会有一个节点(根节点)
2. 树由节点组成，每个节点的数据结构包括一个数据和两个分叉

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/13524038-2de9f46e8f98348f.png)

​											常用:a:空二叉树、:b:只有一个根节点、c:只有左子树、d:只有右子树、e:完全二叉树

其中:

1. 二叉树的每个结点至多只有2棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。
2. 二叉树的第i层至多有2^(i-1)个结点；深度为k的二叉树至多有2^k-1个结点。
3. 一棵深度为k，且有2^k-1个节点的二叉树称之为 **满二叉树** ；
4. 深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为 **完全二叉树** 。

如:

​	![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/2243690-531c8fbb6b2b55c4.jpg)

java简单实现:

- 节点:

```java
@NoArgsConstructor
@Data
public class TreeNode {
  // 数据
  private int value;
  // 左节点
  private TreeNode leftNode;
  //右节点
  private TreeNode rightNode;

    public TreeNode(int value) {
        this.value = value;
    }
}
```

- main方法

```java
 public static void main(String[] args) {
    // 根节点-->10
    TreeNode treeNode = new TreeNode(10);
    // 左-->9
    TreeNode treeNode2 = new TreeNode(9);
    // 右-->20
    TreeNode treeNode3 = new TreeNode(20);
    // 20的左-->15
    TreeNode treeNode4 = new TreeNode(15);
    // 20的右-->35
    TreeNode treeNode5 = new TreeNode(35);

    //连接
    treeNode.setLeftNode(treeNode2);
    treeNode.setRightNode(treeNode3);

    treeNode3.setLeftNode(treeNode4);
    treeNode3.setRightNode(treeNode5);

    System.out.println(treeNode);
  }
```

理想实现结果显示:

![image-20210801164155066](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210801164155066.png)

打印出来后:

```java
TreeNode(value=10, leftNode=TreeNode(value=9, leftNode=null, rightNode=null), rightNode=TreeNode(value=20, leftNode=TreeNode(value=15, leftNode=null, rightNode=null), rightNode=TreeNode(value=35, leftNode=null, rightNode=null)))
```

认真看后也差不多就是那样子的结构,嘿嘿嘿,就是简单实现了而已!

------

二叉树遍历的三种方式:

1. 中序遍历
   - 先访问根节点,然后再访问左节点,然后访问右节点(根->左->右)
2. 先序遍历
   - 先访问左节点,然后再访问根节点,然后访问右节点(左->根->右)
3. 后序遍历
   - 先访问左节点,然后再访问右节点,最后访问根节点(左->右->根)

就以上面的图举例:

- 中序遍历(10->9->20->15->35)
  - 这里执行流程:先访问左节点9然后访问根节点10,然后执行右节点,在节点中获取到有子节点,所以此时把右节点可以看成一个根节点,所以根据中序遍历,先去找15,然后照20,最后才会去35
- 先序遍历(9->10->15->20->35)
  - 这里执行流程:先访问左节点9,然后访问根节点,所以这里是10,然后执行到右节点发现这里有子节点,所以在子节点里执行先序遍历,所以这里获取的是15然后是20最后才是35
- 后序遍历(9->15->35->20->10)
  - 这里执行流程:先访问9节点，随后应该访问的是20节点，但20下还有子节点，因此先访问的是20的左节点15节点。由于15节点没有子节点了。所以就去访问35节点，由于35节点也没有子节点了，所以返回20节点，最终返回10节点

**总结:**中序(根->左->右)，先序(左->根->右)，后序(左->右->根)。如果访问有孩子的节点，先处理孩子的，随后返回

1. 每个节点的遍历如果访问有子节点的节点，先处理子节点的(逻辑是一样的)
2. 因此遍历的方法是递归
3. 递归的出口就是：当没有子节点了，结束遍历

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/2243690-31f7af0f603e84ae.png)

**树与二叉树的区别:**

1. 二叉树每个节点最多有2个子节点，树则无限制。
2. 二叉树中节点的子树分为左子树和右子树，即使某节点只有一棵子树，也要指明该子树是左子树还是右子树，即二叉树是有序的
3. 树决不能为空，它至少有一个节点，而一棵二叉树可以是空的。



##### 2.2.1.3 普通二叉树

**概念:**每个子节点的父节点不一定有两个子节点的二叉树

##### 2.2.1.4 完全二叉树

**概念:**对于一颗二叉树,假设其[深度](对于任意节点n，n的深度为从根到n的唯一路径长，根的深度为0)为d(d>1)。除了第d层外，其他各层的节点数目均已达最大值，且第d层所有节点从左往右连续地紧密排列

##### 2.2.1.5 满二叉树

**概念：**一颗每一层的节点数都达到了最大值的二叉树。有两种表现形式，第一种，像下图这样（每一层都是满的），满足每一层的节点数都达到了最大值 2。



![image-20210813214323377](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210813214323377.png)

##### 2.2.1.6 二叉查找树

特点:

1. 任意节点的左子树不空，左子树上所有节点的值均小于它的根节点的值
2. 任意节点的右子树不空，右子树上所有节点的值均大于它的根节点的值；
3. 任意节点的左、右子树也分别为二叉查找树。

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/77094b36acaf2edda159cae178c5cbef3801936e.jpeg)

这里关于二叉查找树的平均查找公式:

[]: https://blog.csdn.net/qq_42363032/article/details/104248557	"二叉树的平均查找次数"

优点:增删改查的性能都很高! 

**注意:**二叉查找树存在的问题：会出现"瘸子"的现象，影响查询效率。

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/91ef76c6a7efce1ba4e96ac55c8439d8b68f65df.jpeg)



##### 2.2.1.7 平衡二叉树

**概述:**为了避免出现"瘸子"的现象，减少树的高度，提高我们的搜素效率，又存在一种树的结构："平衡二叉树"

> 平衡二叉树本质上还是一颗二叉查找树

**规则:**它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树

![是否为平衡二叉树例图](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20180829143433419)

判断平衡二叉树:

1. 是二叉查找树
2. 任何一个节点的左子树或者右子树都是[平衡二叉树](左右高度小于等于,也叫绝对值不能大于1)

平衡因子:

定义:左子树和右子树高度差

计算:左子树高度-右子树高度的值

比如:就拿上面右边那张图来说,首先拿15这个节点来说,它的左子树没有所以为0,而右边有两个节点,所以2-0=2 ,所以违背了绝对值大于1的概念,所以这个不是平衡二叉树

<img src="https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-6f2e86b1231b5df131813dc45f8f98cb_720w.jpg" alt="img" style="zoom: 50%;" />

<img src="https://i.loli.net/2021/08/16/A7cRnIq9v6PmahJ.jpg" alt="img" style="zoom: 50%;" />

<img src="https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-ba3929eafa5c6a32b1db0402850a321d_720w.jpg" alt="img" style="zoom:50%;" />

经过上面的平衡因子所以可以对各个节点进行标点:

![平衡二叉树](https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-3641cb45e889c1d344e9164c95a0644f_1440w.jpg)

- 左子树跟右子树高度一样则为0
- 左子树比右子树少一个则-1
- 左子树比右子树多一个则1



**理解:**这个高度差我也是思考了许久现在才大致了解一点,所谓的高度差就是以某个节点为中心,计算它的左子树根右子树的层级有多少,然后相减取绝对值,如果大于1那么这不是 **平衡二叉树**

来个错误例子:

<img src="https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-e090a8e3171c8db07e1cda720039e700_720w.jpg" alt="img" style="zoom:50%;" />

首先我们就以60为根节点来计算平衡因子,首先60的子节点(不包括本身哈)有2个层级,然后右子树没有所以为0,这里就2-0所以为2,不符合规则!

##### 2.2.1.8 红黑树

**概念:**红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构，它是在1972年由Rudolf Bayer发明的，当时被称之为平衡二叉B树，后来，在1978年被Leoj.Guibas和Robert Sedgewick修改为如今的"红黑树"。它是一种特殊的二叉查找树，红黑树的每一个节点上都有存储位表示节点的颜色，可以是红或者黑；

红黑树不是高度平衡的，它的平衡是通过"红黑树的特性"进行实现的；

> 红黑树是一种常见的平衡二叉树，节点是红色或是黑色，通过颜色的约束来维持二叉树的平衡

**特性:**

1. 每一个节点或是红色的，或者是黑色的。
2. 根节点必须是黑色
3. 每个叶节点(Nil)是黑色的；（如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点）
4. 如果某一个节点是红色，那么它的子节点必须是黑色(不能出现两个红色节点相连的情况)
5. 对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点；

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/b21bb051f81986186b2f35a8bc38e4758ad4e68b.png)

在进行元素插入的时候，和之前一样； 每一次插入完毕以后，使用黑色规则进行校验，如果不满足红黑规则，就需要通过变色，左旋和右旋来调整树，使其满足红黑规则；

红黑树自平衡基本操作：

- 变色：在不违反上述红黑树规则特点情况下，将红黑树某个node节点颜色由红变黑，或者由黑变红；
- 左旋：逆时针旋转两个节点，让一个节点被其右子节点取代，而该节点成为右子节点的左子节点
- 右旋：顺时针旋转两个节点，让一个节点被其左子节点取代，而该节点成为左子节点的右子节点

左旋转:

​	左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。

​	看一张动态图大概了解下:

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20190412173340503.gif)

​	具体旋转过程:

<img src="https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-28ee4161b6eb77bf442af82a24abd481_720w.jpg" alt="img" style="zoom:50%;" />

右旋转:

​	右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/201904122012257.gif)

<img src="https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-e133500389d089b3139415bbf5af5a06_720w.jpg" alt="img" style="zoom:50%;" />

##### 2.2.1.9 B树

一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个的子树。

> B树又称B-树,是一种多路查找树

**概念:**B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点;

**规则:**

1. 排序方式:所有节点关键字是按递增次序排列，并遵循左小右大原则；
2. 子节点数:非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；
3. 关键字数:枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
4. 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;

最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C>B>A）

![在这里插入图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20190822112219861.png)

**B树的查找流程:**

比如我们要查E字母,那么流程就应该:

1. 获取根节点的关键字进行比较，当前根节点关键字为M，E<M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；
2. 拿到关键字D和G，D<E<G 所以直接找到D和G中间的节点；
3. 拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；

**B树插入节点流程:**

定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来;

插入节点的规则:

- 节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须<=5-1（这里关键字数>4就要进行节点拆分）；
- 排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;
  先插入 3、8、31、11

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20190822142608760.png)

​	再插入23、29

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20190822142625179.png)

再插入50、28

​	![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20190822142635318.png)

**B树的节点删除:**

规则:

1. 节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数<2就要进行节点合并）；

2. 满足节点本身比左边节点大，比右边节点小的排序规则;

3. 关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；

   ![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20190822142708959.png)

**B的特点:**

```
B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;
```

##### 2.2.1.10 B+树

**概念:**B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别;

**规则:**

1. B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加;
2. B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；
3. B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。
4. 非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;

![image-20210813221045771](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210813221045771.png)

**B+树的特点:**

1. B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；
2. B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
3. B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
4. B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

**B+树的总结:**

> B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。

##### 2.2.1.11 B*树

**规则:**

B*树是B+树的变种，相对于B+树他们的不同之处如下：

1. 首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b*树的初始化个数为（cei(2/3*m)）
2. B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；

**特点:**

在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20190822142936722.png)

**总结:**

1. 相同思想和策略
   - 从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；
2. 不同的方式的磁盘空间利用
   - 不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；

#### 2.2.2 哈希表

**概念:**哈希表（Hash Table），也叫散列表，是一种可以通过关键码值（key-value）直接访问的数据结构，它最大的特点就是可以快速实现查找、插入和删除。其中用到的算法叫做哈希，就是把任意长度的输入，变换成固定长度的输出，该输出就是哈希值。像 MD5、SHA1 都用的是哈希算法。

> 每一个 Java 对象都会有一个哈希值，默认情况就是通过调用本地方法执行哈希算法，计算出对象的内存地址 + 对象的值的关键码值。

数组的最大特点就是查找容易，插入和删除困难；而链表正好相反，查找困难，而插入和删除容易。哈希表很完美地结合了两者的优点， Java 的 HashMap 在此基础上还加入了树的优点。

![image-20210813221841525](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210813221841525.png)

**哈希表的优点:**哈希表具有较快（常量级）的查询速度，以及相对较快的增删速度，所以很适合在海量数据的环境中使用。

**注意:**对于任意两个不同的数据块，其哈希值相同的可能性极小，也就是说，对于一个给定的数据块，找到和它哈希值相同的数据块极为困难。再者，对于一个数据块，哪怕只改动它的一个比特位，其哈希值的改动也会非常的大——这正是 Hash 存在的价值！尽管可能性极小，但仍然会发生，如果哈希冲突了，Java 的 HashMap 会在数组的同一个位置上增加链表，如果链表的长度大于 8，将会转化成红黑树进行处理——这就是所谓的拉链法（数组+链表）。



#### 2.2.3 图

图是一种复杂的非线性结构，由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。

![image-20210813222241527](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210813222241527.png)

上图共有 V0，V1，V2，V3 这 4 个顶点，4 个顶点之间共有 5 条边

### 2.3 总结

- 在线性结构中,数据元素之间满足唯一的线性关系,每个数据元素(除第一个和最后一个外)均有唯一的"前驱"和"后继";
- 在树形结构中,数据元素之间有着明显的层次关系,并且每个数据元素只与上一层中的一个元素(父节点)及下一层的多个元素(子节点)相关;
- 在图形结构中,节点之间的关系时任意的,图中任意两个数据元素之间都有可能相关;

