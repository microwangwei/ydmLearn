# 序列化

inputStream:翻译为输入,outPutStream:翻译为输出

向文件写入东西时采用的是outStream,而读文件采用的inputStream

不妨这样理解:以"文件"为中心,文件是空的是要被**写入**东西的,这叫做输出到文件里. 而文件是有东西要读取的采用的输入,也可理解为**读取** 

> inputStream:读取 outPutStream:写入

## 1.序列化有什么用?

原意:序列化意图是希望对Java对象做一下"变换",变成**字节序列**,这样一来方便持久化存储到磁盘中,避免程序运行结束后对象就从内存里消失,另外变换成字节序列也更便于网络传输和传播。从某种意义上将也弥补了平台化的一些差异，毕竟转换后的字节流可以在其他平台上进行反序列化来恢复对象。

- 序列化:把Java对象转换为字节序列。
- 反序列化:把字节序列恢复为原先的Java对象。

理解：转换成字节流存储到电脑里的硬盘里，方便存储和网络传输，避免程序运行完就结束了。

## 2.序列化方式

java对象要序列化得实现两个接口之一：

- Serializable 接口
- Externalizable 接口

## 3.Serializable 接口

一个对象想要被序列化,那么它的类就要实现此接口,这个对象的所有属性(包括private属性,包括其引用的对象)都可以被序列化和反序列化来保存、传递。不想序列化的字段可以使用**transient**修饰.

由于Serializable对象完全以它的存储二进制为基础来构造,因此并不会调用任何构造函数,因此Serializable类**无需默认构造函数**,但是当Serializable类的父类没有实现Serializable接口时，反序列化过程会调用父类的默认构造函数，因此该父类必需有默认构造函数，否则会抛异常。

使用transient关键字阻止序列化虽然简单方便，但被它修饰的属性被完全隔离在序列化机制之外，导致了在反序列化时无法获取该属性的值，而通过在需要序列化的对象的Java类里加入writeObject()方法与readObject()方法可以控制如何序列化各属性，甚至完全不序列化某些属性或者加密序列化某些属性.



## 4.Externalizable 接口

它是Serializable接口的子类，用户要实现的**writeExternal()**和**readExternal()** 方法，用来决定如何序列化和反序列化。因为序列化和反序列化方法需要自己实现，因此可以指定序列化哪些属性，而**transient在这里无效**。对Externalizable对象反序列化时，会先调用类的无参构造方法，这是有别于默认反序列方式的。如果把类的不带参数的构造方法删除，或者把该构造方法的访问权限设置为private、默认或protected级别，会抛出java.io.InvalidException: no valid constructor异常，因此Externalizable对象必须有默认构造函数，而且必需是public的。

## 5. 对比使用:

隐藏属性:比如你只想隐藏一个属性，比如用户对象user的密码pwd，如果使用Externalizable，并除了pwd之外的**每个属性都写**在writeExternal()方法里，这样显得麻烦，可以使用Serializable接口，并在要隐藏的属性pwd前面加上**transient就可以实现**了。如果要定义很多的特殊处理，就可以使用Externalizable。

方法使用对比:Serializable 中的writeObject()方法与readObject()方法与Externalizable 中的writeExternal()和readExternal() 方法:

- writeObject()、readObject()和writeExternal()、readExternal()只是方法签名不一样其方法体都是一致的！
- 虽然使用Externalizable接口性能会提升，但是会导致复杂度增加，所以一般都是使用Serializable接口进行序列化

> 注意：当使用Externalizable机制反序列化该对象时，程序会使用public的无参构造器创建实例，然后才执行readExternal()方法进行反序列化，因此实现Externalizable的序列化类必须提供public的无参构造。

## 6.Serializable使用：

### 6.1 实例及其说明:

特别注明:然而Java目前并没有一个关键字可以直接去定义一个所谓的“可持久化”对象。

对象的持久化和反持久化需要靠程序员在代码里手动**显式地**进行序列化和反序列化还原的动作。

```java
序列化的类:
@Data
@Accessors(chain = true)
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class Student implements Serializable {

    private static final long serialVersionUID = 3668027925019058147L;
    private String name="zhangsan";
    private Integer age;
    private  transient Integer sex; //打上transient修饰,那么就不会被序列化
}
main方法主类:
 public static void test() throws IOException,ClassNotFoundException {
        Student student = new Student();
        student.setName("张三测试序列化");
        student.setAge(1);
        student.setSex(2);

        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(new File("C:\\Users\\MiaoDaWei\\Desktop\\student.txt")));
        objectOutputStream.writeObject(student);
        objectOutputStream.close();

        System.out.println("序列化成功！已经生成student.txt文件");
        System.out.println("==============================================");

        ObjectInputStream objectInputStream =
                new ObjectInputStream( new FileInputStream("C:\\Users\\MiaoDaWei\\Desktop\\student.txt") );
        Student student1 = (Student) objectInputStream.readObject();
        objectInputStream.close();

        System.out.println("反序列化结果为：");
        System.out.println( student1 );
    }
```

结果:

```tex
序列化成功！已经生成student.txt文件
==============================================
反序列化结果为：
Student(name=张三测试序列化, age=1, sex=null)
```

### 6.2 源码解析:

上面在定义Student类时，实现了一个Serializable接口，然而当我们点进Serializable接口内部查看，发现它竟然是一个空接口，并没有包含任何方法！

![image-20210724220937363](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210724220937363.png)

试想如果没有实现这个接口那么又会发生什么?实验结果是：此时的程序运行会报错，并抛出NotSerializableException异常：

![v2-b44def01e3f3c88f5822baa6a2c45ba2_720w](https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-b44def01e3f3c88f5822baa6a2c45ba2_720w.jpg)

再追其源码一直到ObjectOutputStream的writeObject0()方法底层一看:

![image-20210816160256736](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210816160256736.png)

发现首先会判断一个对象既不是字符串、数组、枚举、也没有实现Serizable接口,此时就会报出**NotSerializableException**异常！

> 此时就可以判断原来Serializable接口也仅仅只是做一个标记用！它只是告诉代码只要是实现了Serializable接口的类都是可以被序列化的！然而真正的序列化动作不需要靠它完成。

### 6.3 serialVersionUID号有何用？

我们常常在实现接口的时候都会定义一个**serialVersionUID**这个字段,但是一直不知道这是什么意思,那么往下再看看:

```java
private static final long serialVersionUID = 3668027925019058147L;
```

那假如没有显示声明一个serialVersionUID会发生什么样的情况:

首先:定义一个Student类,并没有声明serialVersionUID:

```java
@Data
@Accessors(chain = true)
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class Student implements Serializable {

//    private static final long serialVersionUID = 3668027925019058147L;
    private String name="zhangsan";
    private Integer age;
    private  transient Integer sex;
}
```

然后开始序列化写入文件里:

```java
Student student = new Student();
        student.setName("张三测试序列化");
        student.setAge(1);
        student.setSex(2);

        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(new File("C:\\Users\\MiaoDaWei\\Desktop\\student.txt")));
        objectOutputStream.writeObject(student);
        objectOutputStream.close();

        System.out.println("序列化成功！已经生成student.txt文件");
        System.out.println("==============================================");
```

此时我们动了点手脚把Student进行修改一下:**增加一个字段**

```java
@Data
@Accessors(chain = true)
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class Student implements Serializable {

//    private static final long serialVersionUID = 3668027925019058147L;
    private String name="zhangsan";
    private Integer age;
    private  transient Integer sex;
    private Integer id;  //增加一个字段
}
```

然后在进行反序列化还原这个Student的时候就发生了变化:

```java
ObjectInputStream objectInputStream =
        new ObjectInputStream( new FileInputStream("C:\\Users\\MiaoDaWei\\Desktop\\student.txt") );
Student student1 = (Student) objectInputStream.readObject();
objectInputStream.close();

System.out.println("反序列化结果为：");
System.out.println( student1 );
```

看结果:

```java
Exception in thread "main" java.io.InvalidClassException: org.work_0723.Student; local class incompatible: stream classdesc serialVersionUID = -612182636439740090, local class serialVersionUID = 8581205978859375064
	at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699)
	at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1885)
	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)
	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)
	at org.work_0723.main.test(main.java:32)
	at org.work_0723.main.main(main.java:14)
```



结论:序列化前后的serialVersionUID号码不兼容！

得出一个重要结论:

1. serialVersionUID是序列化前后的唯一标识符
2. 默认如果没有人为显式定义过serialVersionUID，那编译器会为它自动声明一个！
3. serialVersionUID序列化ID，可以看成是序列化和反序列化过程中的“暗号”，在反序列化时，JVM会把字节流中的序列号ID和被序列化类中的序列号ID做比对，只有两者一致，才能重新反序列化，否则就会报异常来终止反序列化的过程。
4. 如果在定义一个可序列化的类时，没有人为显式地给它定义一个serialVersionUID的话，则Java运行时环境会根据该类的各方面信息自动地为它生成一个默认的serialVersionUID，一旦像上面一样更改了类的结构或者信息，则类的serialVersionUID也会跟着变化！

> 总结:为了serialVersionUID的确定性,凡是implements Serializable的类，都最好人为显式地为它声明一个serialVersionUID明确值！

### 6.4 几种情况不会序列化:

1. 凡是被static修饰的字段是不会被序列化的
2. 凡是被transient修饰符修饰的字段也是不会被序列化的

解释:第一点因为**序列化保存的是对象的状态而非类的状态**，所以会忽略static静态域也是理所应当的。

## 7.实现 Externalizab|e

上代码:

```java
@Data
@Accessors(chain = true)
@NoArgsConstructor
@ToString
public class Student implements Externalizable {

    private String name;
    private Integer age;
    private Integer sex;
    private Integer id;

    public Student(String name,Integer sex) {
        this.name = name;
        this.sex=sex;
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        //  指定序列化时候写入的属性。这里仍然不写入年龄
        out.writeObject(this.name);
        out.writeObject(this.age);
        out.writeObject(this.sex);
        out.writeObject(this.id);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        // 指定反序列化的时候读取属性的顺序以及读取的属性
        // 如果你写反了属性读取的顺序，你可以发现反序列化的读取的对象的指定的属性值也会与你写的读取方式一一对应。因为在文件中装载对象是有序的
        this.name=(String) in.readObject();
        this.age=(Integer) in.readObject();
        this.sex = (Integer) in.readObject();
        this.id = (Integer) in.readObject();

    }
}
```

我们在序列化对象的时候，由于这个类实现了Externalizable 接口，在writeExternal()方法里定义了哪些属性可以序列化，哪些不可以序列化，所以，对象在经过这里就把规定能被序列化的序列化保存文件，**不能序列化的不处理**，然后在反序列的时候自动调用readExternal()方法，**根据序列顺序挨个读取进行反序列**，并自动封装成对象返回，然后在测试类接收，就完成了反序列。

Externalizable 实例类的唯一特性是可以**被写入序列化流中**，该类负责保存和恢复实例内容。 若某个要完全控制某一对象及其超类型的流格式和内容，则它要实现 Externalizable 接口的 writeExternal 和 readExternal 方法。这些方法必须显式与超类型进行协调以保存其状态。这些方法将代替定制的 writeObject 和 readObject 方法实现

理解:实现接口 Externalizable接口覆写 writeExternal跟readExternal方法,进行**写入和读取**,这两个接口都是系统自动调用,其中不想被序列化的可在writeExternal里不写属性就是了,较为方便,写了就序列化不写就不序列化。但是要注意的地方就是在读取的时候**顺序一致**也就是一一对应！之所以要以一一对应是因为是被写入了序列化流中！

测试：

```java
public static void test() throws IOException,ClassNotFoundException {
        Student student = new Student("张三测试序列化",12);

        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(new File("C:\\Users\\MiaoDaWei\\Desktop\\student.txt")));
        objectOutputStream.writeObject(student);
        objectOutputStream.close();

        System.out.println("序列化成功！已经生成student.txt文件");
        System.out.println("==============================================");

        ObjectInputStream objectInputStream =
                new ObjectInputStream( new FileInputStream("C:\\Users\\MiaoDaWei\\Desktop\\student.txt") );
        Student student1 = (Student) objectInputStream.readObject();
        objectInputStream.close();

        System.out.println("反序列化结果为：");
        System.out.println( student1 );
    }
```

结果:

```html
序列化成功！已经生成student.txt文件
==============================================
反序列化结果为：
Student(name=张三测试序列化, age=null, sex=12, id=null)
```

1. write External(objectoutput out)

   该对象可实现 writeExternal 方法来保存其内容，它可以通过调用 DataOutput 的方法来保存其基本值，或调用 ObjectOutput 的 writeObject 方法来保存对象、字符串和数组。

2. read External(objectInput in)

   对象实现 readExternal 方法来恢复其内容，它通过调用 DataInput 的方法来恢复其基础类型，调用 readObject 来恢复对象、字符串和数组。

## 8.externa|izable和 Serializable的区别

1. 实现serializable接口是默认序列化所有属性，**如果有不需要序列化的属性使用transient修饰**。externalizable接口是serializable的子类，实现这个接口需要重写writeExternal和readExternal方法，**指定对象序列化的属性**和从序列化文件中读取对象属性的行为。
2. 实现serializable接口的对象序列化文件进行**反序列化不走构造方法**，载入的是该类对象的一个**持久化状态**，再将这个状态赋值给该类的另一个变量。实现externalizable接口的对象序列化文件进行反序列化**先走构造方法得到控对象**，然后调用readExternal方法读取序列化文件中的内容给对应的属性赋值。
3. 也可以理解为:不想被序列化的字段较多,优先选择externa|izable,较少那么选择Serializable

## 9.序列化的受控和加强

### 9.1 约束性加持

我们在写入到读取的过程中是写入系统硬盘里的,那么这个其实也是有漏洞的如果这个中间过程的被人拿到中间流加以篡改,那么序列化出来的数据都是不确定性的,是有危险的!而反序列化就好比对象的构造与创建;

我们可以自行编写readObject()函数，用于对象的反序列化构造，从而提供约束性:



这里就举个列子:

既然自行编写readObject()函数，那就可以做很多可控的事情：比如各种判断工作。

还以上面的Student类为例，一般来说学生的成绩应该在0 ~ 100之间，我们为了防止学生的考试成绩在反序列化时被别人篡改成一个奇葩值，我们可以自行编写readObject()函数用于反序列化的控制：

```java
@Data
@Accessors(chain = true)
@NoArgsConstructor
@ToString
public class Student implements Serializable {

    private static final long serialVersionUID = 3668027925019058147L;
    private String name;
    private Integer age;
    private  transient Integer sex;
    private Integer id;

    public Student(String name,Integer age) {
        this.name = name;
        this.age=age;
    }
    private void readObject( ObjectInputStream objectInputStream ) throws IOException, ClassNotFoundException {
        System.out.println("自定义readObject");
        // 调用默认的反序列化函数
        objectInputStream.defaultReadObject();

        // 手工检查反序列化后学生成绩的有效性，若发现有问题，即终止操作！
        if( 0 > age || 100 < age ) {
            throw new IllegalArgumentException("学生年龄只能在0到100之间！");
        }
    }
}
//测试类:
public static void test() throws IOException,ClassNotFoundException {
        Student student = new Student("张三测试序列化",101);

        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(new File("C:\\Users\\MiaoDaWei\\Desktop\\student.txt")));
        objectOutputStream.writeObject(student);
        objectOutputStream.close();

        System.out.println("序列化成功！已经生成student.txt文件");
        System.out.println("==============================================");

        ObjectInputStream objectInputStream =
                new ObjectInputStream( new FileInputStream("C:\\Users\\MiaoDaWei\\Desktop\\student.txt") );
        Student student1 = (Student) objectInputStream.readObject();
        objectInputStream.close();

        System.out.println("反序列化结果为：");
        System.out.println( student1 );
    }
```

比如我故意将学生的分数改为101，此时反序列化立马终止并且报错：

![image-20210724233146838](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210724233146838.png)

对于上面的代码，为什么自定义的private的readObject()方法可以被自动调用，跟一下底层源码来一探究竟，跟到了ObjectStreamClass类的最底层，是反射机制在起作用！

> 这个自定义注解经我目前测试,好像只能实现Serializable接口的才有效,并且在实现接口的类中进行自定义实现

