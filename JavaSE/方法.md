# 方法

## 1.基本数据结构

### 1.1 修饰符:

决定方法的调用方式。例如，是用类名调用，还是用对象名调用1

### 1.2.返回值类型:

#### 1.2.1 作用:

决定在调用方法的时候，是否可以用一个变量接收方法的结果值,如果返回值类型是void，表示没有任何返回值，不能用变量接收结果值。

#### 1.2.2返回值:

就是处理完业务后的结果反馈。通过关键字 return 返回数据

#### 1.2.3返回值类型分类:

1. 基本数据类型:byte/short/int/long/float/double/boolean/char
2. 引用类型:类、抽象类、接口、枚举、数组
3. void:表示没有任何返回值

#### 1.2.4方法名:

1. 作用:决定调用哪一个方法（就是用来找到要使用的方法的）
2. 命名原则:见名知意，小驼峰，不能以关键字命名。

#### 1.2.5形参列表:

就是用了接收调用方法的时候，传入的实际参数（值/变量）的

#### 1.2.6 方法体:

就是根据实际需求，处理数据的代码

#### 1.2.7方法签名:

**同一个类中，只能有一个独一无二的方法签名**

方法名+形参列表（参数的顺序、类型和个数）,跟形参名字无关

> 形参列表3要素:参数的顺序、类型和个数

## 2.方法使用:

### 2.1方法四要素:

1. 返回值类型
2. 方法名
3. 形参列表
4. 方法体

**可根据实际需求,而去修改方法四要素**

### 2.2方法的调用:

最主要的一点就是看是否存在**static**修饰符

1. 存在:调用时用当前类名.方法名(实参(变量/值))
2. 不存在:调用时用对象名.方法名(实参(变量/值))

> 如果调用方（目前就是指main方法）和被调用方都在同一个类中，且都有或者都没有static修饰，可以简写为：方法名(实参(变量/值));

注意:**调用方法的时候，传入的参数数量、数据类型、顺序必须和 声明方法的一致**

## 3.方法重载

### 3.1概念:

在同一个类中，方法名相同，形参列表不同，就是方法重载

### 3.2作用:

1. 可以减少命名冲突
2. 可以减少程序员记忆成本,方便解决了一类问题

### 3.3使用

1. 声明方法的时候，写不同的形参即可。
2. 调用方法的时候，程序会根据参数数量、类型、顺序自动匹配调用的

### 注意事项

- 方法调用的时候，实参(变量/值) 必须和 形参完全一致
- 一个类中，只能有一个方法签名
-  返回值类型是void，不能用变量接受，不能放在打印语句中
- 返回值不是void，必须return一个数据，并且数据类型和返回值类型完全一致
-  return的数据，如果在if或者循环语句中，必须保证在条件语句和循环语句不成立的情况下，也有数据的返回

## 4.可变参数

### 4.1概念:

就是将方法参数个数不定的需求简化的一种语法，本质是数组。

### 4.2 作用:

简化代码，将数组的创建工作交给了编译器。

### 4.3 语法:

业务场景:当参数个数不确定,那么应该通过数组作为形参,这样的话就可以传入任意数据

```java
修饰符 返回值类型 方法名(其他数据类型  变量,数据类型... 变量){// 在调用这个方法的时候，可以传入多个相同类型的实参，实参之间用逗号隔开
			方法体		
}
```

> 1. 可变参数本质就是一个数组，只不过这个数组是编译器帮我们程序员创建的
> 2. 一个方法只能有一个可变参数，并且只能在形参列表最末尾

**注意:**实参传递的时候可以{1,2,3}传到可变参数的方法编译器会自动创建new 数组,可如果在传递参数是创建了数组那么也是可以的,就省略了编译器的工作

### 4.4 反编译图

这是正常java文件代码:

```java
public class Study {
    public static void main(String[] args) {
        System.out.println(getSum(1, 2, 3, 4));
    }

    private static int getSum(int... arr) {
        return Arrays.stream(arr).sum();
    }
}
```

这是反编译后的代码:

```java
package work_0721;

import java.io.PrintStream;
import java.util.Arrays;
import java.util.stream.IntStream;

public class Study
{
  public static void main(String[] args)
  {
    System.out.println(getSum(new int[] { 1, 2, 3, 4 }));
  }

  private static int getSum(int[] arr) {
    return Arrays.stream(arr).sum();
  }
}
```

总结:在实参传递时java编译器会默认创建一个数组并初始化赋值,而可变参数实质也是属于数组!

## 5.Arrays中常用方法:

### 5.1拼接数组中元素

```java
public static String toString(int[] arr)
```

### 5.2将数组中的元素排序

```java
public static void sort(int[] arr)
```

**注意:**默认升序。从小到大

### 5.3 查询变量a在数组arr中第一次出现的下标

```java
public static int binarySearch(int[] arr,int a)
```

**注意:**如果没有找到返回 负数

> 这里必须要求数组是排好顺序的(升序或者降序都是可以的)、不能出现重复的元素(不是不能而是如果出现多个重复那么此时下标也是不确定性的)

**二分查找:**比如1-50从1开始连续查找,这称之为**线性查找**

​	首先会取最大值50取半就是25,这时就会判断查询的值是否大于还是小于,如果小了那么此时又会缩短范围->1~24中取12,这时小了,那么就取13~24这个范围然后取中间值....依次就是这样依次缩小范围去查找,效率要高

附上图：

![image-20210721194343498](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210721194343498.png)	

### 5.4 数组的扩容和缩容方法

```java
public static int[] copyOf (int[] arr,int newLength)
```

扩容:如果newLength大于arr数组中用来的长度，就是扩容，扩容后，arr数组所有的元素都已经复制到新数组中

缩容:如果newLength小于arr数组中用来的长度，就是缩容，缩容后，arr数组从后向前缩

### 5.5 指定范围复制到新数组中

```java
static int[] copyOfRange(int[] arr, int from, int to) //将指定数组arr的指定下标范围从from到to之间的元素，复制到新数组中。
```

**注意:**含头不含尾

### 5.6 批量初始化

```java
public static void fill(int[] arr,int a) //将数组arr中的元素批量初始化为a
```

### 5.7 以Stream流的形式

```java
//用Stream流形式实现
        int sum = Arrays.stream(arr).sum();
        System.out.println("sum = " + sum);
```

可以快速转为Stream流,然后就可以实现max、min、sum等等数值流的形式进行操作运算

## 6.内存分析图

这里展示的是值传递和引用地址传递的区别？在内存里是如何展示的：

![image-20210721194602708](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210721194602708.png)

值传递:

​	值传递是属于基本类型的传递,不经过堆内存的!分析上面代码发现:首先在程序运行时会在**栈**中创建一个main方法栈帧区（也称**入栈**）,而此时变量int a会首先去这个栈帧区去查找是否存在、不存在则创建声明一个变量,然后将1赋值给它,然后下一步调用change(a)方法,这时就会在栈中创建另一个change方法栈帧区,而在这个方法中的int a会去这个栈区去创建声明,而传递参数1到这个change方法中赋值给这个change栈帧中的int a这个变量。 后面也就是赋值操作从之前指向1的操作改为指向2的操作,当这个change方法区调用完毕那么就会被java虚拟机删除掉,这个过程称之为**"出栈"**

**从一开始到结束就跟main栈区的变量毫无瓜葛可言**

引用地址传递:

​	这个过程跟上面也是一样的,不过也是不一样的,区别点在于在创建除了基本类型(包括String)以外的类型,会首先去**堆内存**创建用于存放元素值,然后将这块元素值的内存地址指向声明在**方法栈帧**中的声明变量里,而传递到change方法栈区中后用变量接收的是一个地址,将地址指向了给它,这是进行赋值等相关操作都会影响堆内存中的元素值。

> 总结:
>
> 1.值传递只是传递"值",并且跟传递方的变量不会产生任何影响.
>
> 2.引用地址传递传递的是"堆内存地址",会影响其原本的元素值,因为操作的元素是直接存在于堆内存中的!
