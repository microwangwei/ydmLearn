# 反射

## 1.什么是反射?

1. 建立知识共识:
   - 要让Java程序能够运行，那么就得让Java类要被Java虚拟机加载;
   - Java类如果不被Java虚拟机加载，是不能正常运行的;
   - 我们运行的所有的程序都是在编译期的时候就已经知道了你所需要的那个类已经被加载了;
2. 官方解释:
   - 反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力;
   - 反射在运行时期,动态地或获取类中的信息(类的信息、方法的信息、构造器信息、字段等信息);

```
什么是反射?
	反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。
反射机制:
	可以动态的获取信息,动态调用对象的方法的功能称为Java语言的反射机制
```

> 简单的理解，通过一个全限定类名，获取字节码文件，以及通过该字节码文件获取字段、构造方法、普通方法等息

反射的功能:

1. 在运行时(动态编译)获知任意一个对象所属类
2. 在运行时构造任意一个类的对象
3. 在运行时获知任意一个类所具有的的成员变量和方法
4. 在运行时调用任意一个对象的方法和属性

反射的作用:

1. 增加程序的灵活性，避免将程序写死到代码里(解除硬编码的问题)；
2. JAVA的反射机制它知道类的基本结构,可以动态的去获取类这样的结构的结构
3. 可以让程序员在不知道其他程序员会有什么类的时候编写完成自己的代码;

反射的优点:

- 灵活、功能强大（可以拿到私有变量）

反射的缺点:

- 破坏了封装,影响性能;

反射的图解:

![image-20210812184030557](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210812184030557.png)

## 2.反射初步使用:

```java
public class Apple {

    private int price;

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public static void main(String[] args) throws Exception{
        //正常的调用
        Apple apple = new Apple();
        apple.setPrice(5);
        System.out.println("Apple Price:" + apple.getPrice());
        //使用反射调用
        Class clz = Class.forName("com.chenshuyi.api.Apple");
        Method setPriceMethod = clz.getMethod("setPrice", int.class);
        Constructor appleConstructor = clz.getConstructor();
        Object appleObj = appleConstructor.newInstance();
        setPriceMethod.invoke(appleObj, 14);
        Method getPriceMethod = clz.getMethod("getPrice");
        System.out.println("Apple Price:" + getPriceMethod.invoke(appleObj));
    }
}
```

上面在新建一个类,然后正常和反射的调用的区别

从代码中可以看到我们使用反射调用了 setPrice 方法，并传递了 14 的值。之后使用反射调用了 getPrice 方法，输出其价格。上面的代码整个的输出结果是：

```java
Apple Price:5
Apple Price:14
```

来我们继续分析每一个步骤获取对象的反射是什么意思:

1. 获取类的Class对象实例

   ```java
    Class clz = Class.forName("com.chenshuyi.api.Apple");
   ```

2. 根据Class对象实例获取Constructor对象

   ```java
   Constructor appleConstructor = clz.getConstructor();
   ```

3. 使用 Constructor 对象的 newInstance 方法获取反射类对象

   ```java
   Object appleObj = appleConstructor.newInstance();
   ```

**注意:**这里使用newInstance获取对象后返回的是Object,这个Object是所有类的父类也是基类,所以这里也可以使用向下转型`Apple apple=(Apple)appleConstructor.newInstance();`,就可以获取到该对象的实例,等同于`Apple apple = new Apple();`

而如果要调用某一个方法,则需要经过以下步骤:

1. 获取方法的Method对象

   ```java
   Method setPriceMethod = clz.getMethod("setPrice", int.class);
   ```

2. 利用invoke方法调用方法

   ```java
   setPriceMethod.invoke(appleObj, 14);
   ```

   

## 3.理解Class类

先来看看官方jdk对Class类的解释:

![image-20210810112728062](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210810112728062.png)

官方解释说这Class类的类表示正在运行的Java应用程序中的类和接口

来继续看看

```java
public final class Class<T> implements java.io.Serializable,
                              GenericDeclaration,
                              Type,
                              AnnotatedElement {}
```

Class类是实现反射的基础,在JVM中始终为所有的对象维护一个被称之为 **运行时的类型标识**,这个标识跟踪着每一个对象所属的类的完整结构信息,包括包名、类名、实现的接口、拥有的方法和字段等。可以通过专门的Java类访问这些信息，这个类就是 **Class**类。 我们可以把Class类理解为 **类的类型**,一个Class对象被称之为类的类型对象

> 一个Class对象对应一个加载到JVM中的一个.class文件

再来说说类的加载过程:

```java
import java.util.Date; // 先有类

public class Test {
    public static void main(String[] args) {
        Date date = new Date(); // 后有对象
        System.out.println(date);
    }
}
```

首先 JVM 会将你的代码编译成一个`.class`字节码文件，然后被类加载器（Class Loader）加载进 JVM 的内存中，**同时会创建一个`Date`类的`Class`对象存到堆中**（注意这个不是 new 出来的对象，而是类的类型对象）。JVM 在创建`Date`对象前，会先检查其类是否加载，寻找类对应的`Class`对象，若加载好，则为其分配内存，然后再进行初始化`new Date()`。

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/v2-baffd6a76821a987eda3b09f2264d762_720w.jpg)

其中Date类的class对象存在堆中,其实更具体来讲是存到堆中的元空间里,每次创建对象前都回去找Class对象是否存在,然后根据Class进行分配内存然后初始化

需要注意的是: **每个类只有一个Class对象**也就是说如果我们有第二条`new Date()`语句，JVM 不会再生成一个`Date`的`Class`对象，因为已经存在一个了。这也使得我们可以利用`==`运算符实现两个类对象比较的操作：

```java
System.out.println(date.getClass() == Date.getClass()); // true
```

然后在加载完一个类后,在堆内存的方法区就产生了一个Class对象,这个对象就包含了完整的类的结构信息, **我们可以通过这个class对象看到类的结构**,他好比一面镜子。所以我亲切的称之为“反射”



Class实例

初步介绍:

1. 其实就是一些类型的字节码对象
2. Class类的实例表示正在运行的JAVA应用程序中的类和接口
3. 枚举是一种类,注释(指的是注解Annotation)是一种接口
4. 每个数组属于被映射为Class对象的一个类,所有具有相同元素类型和维数的数组都共享该Class对象;
5. 基本的JAVA类型(boolean、byte、char、short、int、long、float和double)和关键字void也表示为Class对象

注意:

1. Class类和它的实例的产生:Class的实例是已经存在的类型,所以不能直接new一个Class对象出来,而通过已知类型和Class获得

2. 同一种类型不管通过什么方式得到Class的实例都是相等的;一个类型的字节码对象只有一份!

3. Class的实例就看成是Java中我们学过的数据类型在JVM中存在的一种状态(字节码对象)

   如: String.class  int.class  int[].class



### 3.1 获取Class类对象的四种方式

因为Class是不能进行new,所以只能通过不同方式来进行获取Class对象,因为:

![image-20210810143447736](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210810143447736.png)

构造方法已被私有化,也就是说只有 JVM 可以创建 `Class` 类的对象，我们不能像普通类一样直接 new 一个 `Class` 对象。

接下来就是获取Class类的对象的几种方式:

1. 使用.class方法

   ```java
   Class clz = String.class;//仅适合于知道具体类的情况下可以使用
   ```

2. Class.forName()传入全类名获取:

   ```java
   Class alunbarClass1 = Class.forName("com.xxx.TargetObject");//这是静态方法
   ```

   注意:这个方法底层是会进行初始化操作,意思就是会执行对象里的`static`静态代码块,然后static参数也会被再次初始化

   来看一下:

   ```java
    @CallerSensitive
       public static Class<?> forName(String className)
                   throws ClassNotFoundException {
           Class<?> caller = Reflection.getCallerClass();
           return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
       }
   ```

   //这里ForName0中的第二个参数默认就是true,表示默认为会执行初始化操作

   当然也可以显式的指定不要初始化操作

   ```java
   @CallerSensitive
       public static Class<?> forName(String name, boolean initialize,
                                      ClassLoader loader)
           throws ClassNotFoundException
       {
           Class<?> caller = null;
           SecurityManager sm = System.getSecurityManager();
           if (sm != null) {
               // Reflective call to get caller class is only needed if a security manager
               // is present.  Avoid the overhead of making this call otherwise.
               caller = Reflection.getCallerClass();
               if (loader == null) {
                   ClassLoader ccl = ClassLoader.getClassLoader(caller);
                   if (ccl != null) {
                       sm.checkPermission(
                           SecurityConstants.GET_CLASSLOADER_PERMISSION);
                   }
               }
           }
           return forName0(name, initialize, loader, caller);
       }
   ```

3. 使用类对象的 getClass() 方法:

   ```java
   String str = new String("Hello");
   Class clz = str.getClass();//获取该对象实例的 Class 类对象
   ```

4. 通过类加载器`xxxClassLoader.loadClass()`传入类路径获取

   ```java
   class clazz = ClassLoader.LoadClass("com.xxx.TargetObject");
   ```

   **注意:**通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行。这里可以和 `forName` 做个对比。

这里列出一些常用的例子:

```java
//通过数据类型或字符串都可以获取Class
Class c1 = String.class;
Class c2 = "abc".getClass();
Class c3 = Class.forName("java.lang.String");
//也可以获取接口的Class:
Class clz1 = Class.forName("java.util.List");
Class clz2 = List.class;
Class clz3 = new ArrayList().getClass();
//数组也可以获取Class,每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象
int[] arr1 = new int[10];
int[] arr2 = new int[12];
int[][] arr3 = new int[12][];
System.out.println(arr1.getClass() == arr2.getClass());//true
System.out.println(arr1.getClass() == int[].class); //true
//基本数据类型+void,基本类型的包装类中都分别提供了一个字段保存其基本数据类型的对应的Class实例
Class cla5 = int.class;
Class cla6 = Integer.class;
Class cla7 = Integer.TYPE;
System.out.println(cla5 == cla6); //false
System.out.println(cla5 == cla7); //true
Class cla8 = void.class;
Class cla9 = Void.class;
Class cla10 = Void.TYPE;
System.out.println(cla8==cla9);//false
System.out.println(cla8==cla10); //true
```

这里其中int.class和Integer.TYPE为啥还想等,那么我们来看看源码:

![image-20210810150547127](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210810150547127.png)

可以看出两者共享一个int类型的Class,所以相等而Void.TYPE也是一样的:

![image-20210810150659431](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210810150659431.png)

## 4.创建对象实例:

### 4.1 获得构造器结构的方式:

首先先定义一个类:

```java
/**
 * @program: YmsdLearn
 * @description: 苹果
 * @author: MiaoWei
 * @create: 2021-08-10 10:07
 */
public class Apple1 {
  private int price;

  private Apple1() {}

  public Apple1(String name) {
    System.out.println("name = " + name);
  }

  public int getPrice() {
    return price;
  }

  public void setPrice(int price) {
    this.price = price;
  }
}
```



1. Constructor<T>  getConstructor(Class<?>... parameterTypes)

   通过一个条件得到一个对应的构造方法对象,条件就是构造方法中的形成的类型对应的Class实例

   ```java
   public static void main(String[] args) throws Exception{
         Class<Apple1> aClass = Apple1.class;
        Constructor<Apple1> constructor = aClass.getConstructor(String.class);
       System.out.println("constructor = " + constructor); //constructor = public org.work_0812.Apple1(java.lang.String)
   }
   ```

   意思就是获取Apple1的字节码文件,然后通过`getConstructor`获取构造方法,然后参数就是对应类中构造方法所需参数的Class实例

   **注意:**这里的获取只能是`public`修饰符修饰的,private是获取不到的

2. Constructor<?>[]  getConstructors()

   直接获取对应的Class实例中的所有由public修饰的构造方法,private是获取不到的

   ```java
   public static void main(String[] args) throws Exception{
         Class<Apple1> aClass = Apple1.class;
         Constructor<?>[] constructors = aClass.getConstructors();
         System.out.println("constructors = " + Arrays.toString(constructors));//constructors = [public org.work_0812.Apple1(java.lang.String)]
   }
   ```

3. Constructor<T> getDeclaredConstructor(class<?>... parameterTypes)

   跟第一个功能是一样的,只不过这里对访问权限没有要求,也就是private私有化也是可以获取的

   ```java
   public static void main(String[] args) throws Exception {
       Class<Apple1> aClass = Apple1.class;
       Constructor<Apple1> constructor = aClass.getDeclaredConstructor();
       System.out.println("constructor = " + constructor);//constructor = private org.work_0812.Apple1()
     }
   ```

4. Constructor<?>[] getDeclaredConstructors()

   也是和第2个是一样的,将对应类实例中所有的构造方法装到一个数组中去,**没有访问权限**

   ```java
   public static void main(String[] args) throws Exception {
       Class<Apple1> aClass = Apple1.class;
           Constructor<?>[] constructors = aClass.getDeclaredConstructors();
           Arrays.stream(constructors).forEach(System.out::println);
     }
   //结果:
   //private org.work_0812.Apple1()
   //public org.work_0812.Apple1(java.lang.String)
   ```

   

### 4.2 创建对象

通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。

第一种:通过Class对象的newInstance()方法

```java
Class clz = Apple.class;
Apple apple = (Apple)clz.newInstance();
```

说明:这个直接创建对象,默认则是调用类中的无参构造方法,但是这个无参构造方法必须存在且是Public公有化,否则就会报异常!

**注意:**这种方式在jdk11已经得到废弃了

第二种:通过 Constructor 对象的 newInstance() 方法

```java
Class clz = Apple.class;
Constructor constructor = clz.getConstructor();
Apple apple = (Apple)constructor.newInstance();
```

这种方式就可以自定义获取指定的构造方法,但是也是public的,然后在newInstance()可以传入参数

> 通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。



这里要注意以下如果使用:

```java
Constructor<Apple1> constructor = aClass.getDeclaredConstructor();
```

来进行获取私有化构造函数,然后进行`Apple1 apple1 = constructor.newInstance();`就会报权限问题

![image-20210810163409216](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210810163409216.png)

所以这里就需要处理一下,要让这个权限失效

`void setAccessible(boolean flag) `:它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力;

​	值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查

```java
	Class<Apple1> aClass = Apple1.class;
    Constructor<Apple1> constructor = aClass.getDeclaredConstructor();
    constructor.setAccessible(true);//权限失效
    Apple1 apple1 = constructor.newInstance();//创建对象
    System.out.println("apple1 = " + apple1);
//这是private私有化的构造方法
```



我来一个综合案例:

```java
package org.work_0812.classDemo;

import org.junit.Test;

import java.lang.reflect.Constructor;
import java.util.Arrays;

/**
 * @program: YmsdLearn
 * @description: 反射
 * @author: MiaoWei
 * @create: 2021-08-12 11:43
 */
public class ClassDemoTest1 {
  @Test
  public void test() throws Exception {
    // 获取字节码文件
    final Class<?> userClass = Class.forName("org.work_0812.classDemo.User");
    // 1.通过字节码获取所有public构造方法：getConstructors()
    System.out.println("========================获取全部public修饰的构造方法================================");
    final Constructor<?>[] publicConstructors = userClass.getConstructors();
    Arrays.stream(publicConstructors).forEach(System.out::println);
    // 2.通过字节码获取所有任意权限构造方法：getConstructors()
    System.out.println("========================获取任意修饰符修饰的构造方法================================");
    final Constructor<?>[] privateDeclaredConstructors = userClass.getDeclaredConstructors();
    Arrays.stream(privateDeclaredConstructors).forEach(System.out::println);
    // 3.通过字节码获取：无参构造 public User(),调用方法：getConstructor(Class...)
    System.out.println("========================获取public无参构造方法================================");
    final Constructor<?> constructor = userClass.getConstructor();
    System.out.println(constructor);
    //4.通过字节码获取：2个String参构造 public User(String name, String pwd),调用方法：getConstructor(Class...)
    System.out.println("========================获取public有参构造方法================================");
    final Constructor<?> publicConstructor = userClass.getConstructor(String.class, String.class);
    System.out.println(publicConstructor);
    //5.通过字节码获取：1个private修饰的String参构造private User(String name),调用方法：getConstructor(Class...)
    System.out.println("========================获取private有参构造方法================================");
//    final Constructor<?> privateClassConstructor = userClass.getConstructor(String.class);
//    System.out.println(privateClassConstructor); 不能获取私有化
    System.out.println("========================通过public构造方法创建对象================================");
    // 6.无参构造创建对象【调用方法创建对象的时候不要用错了对象】,通过Constructor对象调用：T newInstance(Object... 实参)
    final Object instance = publicConstructor.newInstance("1", "2");
    System.out.println("instance = " + instance);
    //7.2个String参构造创建对象【调用方法创建对象的时候不要用错了对象】,通过Constructor对象调用：T newInstance(Object... 实参)
    System.out.println("========================通过public构造方法创建对象================================");
    final Object newInstance = constructor.newInstance();
    System.out.println("newInstance = " + newInstance);
    //8.private修饰String参构造创建对象【调用方法创建对象的时候不要用错了对象】,通过Constructor对象调用：T newInstance(Object... 实参)
    System.out.println("========================通过private构造方法创建对象================================");
    final Constructor<?> privateClassConstructor = userClass.getDeclaredConstructor(String.class);
    //这里必须用getDeclaredConstructor来获取private的构造方法,不然也会报错的
    //这里进行破坏权限访问让其下面的创建实例才能继续
    privateClassConstructor.setAccessible(true);
    //注意：private修饰的成员，都必须先破坏封装，才能调用方法执行。谁调用谁破坏
    final Object instance1 = privateClassConstructor.newInstance("王二");
    System.out.println("instance1 = " + instance1);
    // 9.创建对象，还有一种方式,通过Class字节码中，方法：T newInstance() 该Class中方法，只能调用public修饰的无参构造
    System.out.println("========================通过class字节码文件创建对象(无参构造)================================");
    final Object instance2 = userClass.newInstance();
    System.out.println("instance2 = " + instance2);
  }
}
```

结果:

```java
========================获取全部public修饰的构造方法================================
public org.work_0812.classDemo.User()
public org.work_0812.classDemo.User(java.lang.String,java.lang.String)
========================获取任意修饰符修饰的构造方法================================
public org.work_0812.classDemo.User()
private org.work_0812.classDemo.User(java.lang.String)
public org.work_0812.classDemo.User(java.lang.String,java.lang.String)
========================获取public无参构造方法================================
public org.work_0812.classDemo.User()
========================获取public有参构造方法================================
public org.work_0812.classDemo.User(java.lang.String,java.lang.String)
========================获取private有参构造方法================================
========================通过public构造方法创建对象================================
instance =  [1, 2]
========================通过public构造方法创建对象================================
newInstance =  [null, null]
instance1 =  [王二, null]
instance2 =  [null, null]
```

在获取构造方法创建对象中可以得出:使用`getConstructor`只能获取public修饰的,而`getDeclaredConstructor`可以获取private修饰的,以上是能保证获取到的能够不报异常正常执行,然后对应的`newInstance`也得保证获取的构造方法能够访问的基础上传实参进行创建实例,但是如果是private修饰的,那么得用`setAccessible`破坏了访问权限,才可以创建对象

## 5.获取方法

先建一个类再说

```java
/**
 * @program: YmsdLearn
 * @description: 苹果
 * @author: MiaoWei
 * @create: 2021-08-10 10:07
 */
public class Apple1 {
  private int price;

  private Apple1() {
    System.out.println("这是private私有化的构造方法");
  }

  public Apple1(String name) {
    System.out.println("name = " + name);
  }

  public int getPrice() {
    return price;
  }

  public void setPrice(int price) {
    this.price = price;
  }

  public void publicMethod(String name) {
    System.out.println("这是public权限的方法");
  }

  private void privateMethod() {
    System.out.println("这是private权限的方法");
  }
}
```

### 5.1 获得方法结构的方式

1. Method getMethod(String name, Class<?>... parameterTypes)。 

   ```java
   public static void main(String[] args) throws Exception {
       Class<Apple1> aClass = Apple1.class;
       Method method = aClass.getMethod("publicMethod", String.class);
       System.out.println("method = " + method); //method = public void org.work_0812.Apple1.publicMethod(java.lang.String)
     }
   ```

   注意:只能获取public的方法,如果获取的是私有化的那么就会报错,如:

   ![image-20210810165226552](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210810165226552.png)

2. Method[] getMethods() 

   ```java
    public static void main(String[] args) throws Exception {
       Class<Apple1> aClass = Apple1.class;
       Method[] methods = aClass.getMethods();
       Arrays.stream(methods).forEach(System.out::println);
     }
   ```

   **注意:**获取public方法装到一个数组中去,这里会因为该类默认会继承Object类,所以就会把该父类继承下来的public方法也装到数组中去了!

3. Method getDeclaredMethod(String name, Class<?>... parameterTypes) 

   跟方式1是一样的,只不过这里是不受权限限制

4. Method[] getDeclaredMethods() 

   跟方式2是一样的,只不过不受权限控制

> 这里只是获取方法的结构的方式,总共就两种1.获取方法单独的方法 2.获取全部方法



### 5.2 执行方法

通过反射执行方法:

首先定义一个类:

```java
public class A {
    public A(){}
	private void t1(){
		System.out.println("A t1");
	}
	public static void t2(int i){
		System.out.println("A t2");
	}
	private void t3(String s,int i){
		System.out.println("A 3");
	}
	@Override
	public void t5() {
	}
}
```

执行反射方法的步骤:

1. 获得A对应的Class实例；
2. 通过反射得到A中指定的方法体
3. 通过反射(Method类)来调用方法

语法:

​	Object invoke(Object obj, Object... args)

上代码:

```java
Class<A> clz = A.class;
Method m = clz.getMethod("t3", String.class,int.class);
A a = new A();
m.invoke(a, "小猪猪",10);
```

这里的`A a = new A();`其实就是作为构造方法参数传进去,也就是实例传进去作为第一个参数

准确来讲,可以改为:

```java
Class<A> clz = A.class;
Method m = clz.getMethod("t3", String.class,int.class);
m.invoke(clz.getConstructor().newInstance(), "小猪猪",10);    
```

如果在调用的是一个静态方法,比如static方法:

那么在第一个参数传一个null,就可以了



如果调用的是私有化方法,那么此时就会报错的,所以我们就可以用

那什么时候调用的呢?注意记住谁调用谁破坏

```java
void setAccessible(true) ;//取消java权限检查
```

就可以了!

综合案例:

```java
package org.work_0812.classDemo;

import org.junit.Test;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.Arrays;

/**
 * @program: YmsdLearn
 * @description: 反射
 * @author: MiaoWei
 * @create: 2021-08-12 14:08
 */
public class ClassDemoTest2 {
  @Test
  public void test() throws Exception{
    // 获取字节码文件
    final Class<?> userClass = Class.forName("org.work_0812.classDemo.User");
    // 1.通过字节码文件获取普通方法
    System.out.println("======================获取全部普通方法(包括父类)-只有public的=======================================");
    final Method[] superPublicMethods = userClass.getMethods();
    Arrays.stream(superPublicMethods).forEach(System.out::println);
    //2.Method[] methods = clazz.getDeclaredMethods() 获取任意访问权限所有造方法数组，并且都是自己的方法
    System.out.println("======================获取全部普通方法(不包括父类)-任意修饰的=======================================");
    final Method[] privateDeclaredMethods = userClass.getDeclaredMethods();
    Arrays.stream(privateDeclaredMethods).forEach(System.out::println);
    // 3.获取public void test2(String str)有参普通方法
    System.out.println("======================获取指定public修饰的普通方法=======================================");
    final Method publicMethodTest2 = userClass.getMethod("test2", String.class);
    System.out.println("publicMethodTest2 = " + publicMethodTest2);
    //4.获取private void testPrivate()普通方法
    System.out.println("======================获取指定private修饰的普通方法=======================================");
    //    final Method privateMethodTestPrivate = userClass.getMethod("testPrivate");
    final Method privateMethodTestPrivate = userClass.getDeclaredMethod("testPrivate");
    System.out.println("privateMethodTestPrivate = " + privateMethodTestPrivate);
    //5.获取public static void testStatic()普通静态方法
    System.out.println("======================获取指定public修饰的普通静态方法=======================================");
    final Method publicMethodTestStatic = userClass.getMethod("testStatic");
    System.out.println("publicMethodTestStatic = " + publicMethodTestStatic);
    // 执行方法
    final Constructor<?> constructor = userClass.getConstructor();
    final Object instance = constructor.newInstance();
    System.out.println("======================执行普通方法=======================================");
    publicMethodTest2.invoke(instance, "哇塞");
    System.out.println("======================执行静态方法=======================================");
    publicMethodTestStatic.invoke(null);

  }
}
```

结果:

```java
======================获取全部普通方法(包括父类)-只有public的=======================================
public void org.work_0812.classDemo.User.test2(java.lang.String)
public static void org.work_0812.classDemo.User.testStatic()
public java.lang.String org.work_0812.classDemo.User.getPwd()
public void org.work_0812.classDemo.User.setPwd(java.lang.String)
public java.lang.String org.work_0812.classDemo.User.getName()
public boolean org.work_0812.classDemo.User.equals(java.lang.Object)
public java.lang.String org.work_0812.classDemo.User.toString()
public int org.work_0812.classDemo.User.hashCode()
public void org.work_0812.classDemo.User.setName(java.lang.String)
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
======================获取全部普通方法(不包括父类)-任意修饰的=======================================
public void org.work_0812.classDemo.User.test2(java.lang.String)
public static void org.work_0812.classDemo.User.testStatic()
private void org.work_0812.classDemo.User.testPrivate()
public java.lang.String org.work_0812.classDemo.User.getPwd()
public void org.work_0812.classDemo.User.setPwd(java.lang.String)
public java.lang.String org.work_0812.classDemo.User.getName()
public boolean org.work_0812.classDemo.User.equals(java.lang.Object)
public java.lang.String org.work_0812.classDemo.User.toString()
public int org.work_0812.classDemo.User.hashCode()
public void org.work_0812.classDemo.User.setName(java.lang.String)
======================获取指定public修饰的普通方法=======================================
publicMethodTest2 = public void org.work_0812.classDemo.User.test2(java.lang.String)
======================获取指定private修饰的普通方法=======================================
privateMethodTestPrivate = private void org.work_0812.classDemo.User.testPrivate()
======================获取指定public修饰的普通静态方法=======================================
publicMethodTestStatic = public static void org.work_0812.classDemo.User.testStatic()
======================执行public修饰的普通方法=======================================
反射有参非静态方法测试：哇塞
======================执行public修饰的静态方法=======================================
反射静态方法测试
```

执行方法的时候传递的参数必须带有对象,这是因为哪怕我们在正常的new对象然后调用实例方法,也是这样子的,也就是说必须传一个对象才可以,如果获取的是私有化private的方法,那么就用`setAccessible`破坏其访问权限也可以使用

## 6.获取字段

其实获取字段跟上面的方法类型都是一样的;

先来看:

1. Field get Field(string name);获取public权限修饰的字段
2. Field getFields(); 获取全部public权限修饰的字段装成的数组里
3. Field get Field(string name); 获取字段不受权限的限制
4. Field get DeclaredFields(); 获取全部字段(不受权限限制)装到数组中

贴一组代码:

```java
	Class<Apple1> ac = Apple1.class;
    Field price = ac.getDeclaredField("price");
    System.out.println("price = " + price.getName())//price = price
```

案例:

```java
package org.work_0812.classDemo;

import org.junit.Test;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;

/**
 * @program: YmsdLearn
 * @description: 反射
 * @author: MiaoWei
 * @create: 2021-08-12 14:08
 */
public class ClassDemoTest3 {
  @Test
  public void test() throws Exception{
    // 获取字节码文件
    final Class<?> userClass = Class.forName("org.work_0812.classDemo.User");
    // 1.Field[] fields = clazz.getFields() 获取public修饰的字段
    System.out.println("=====================获取public修饰的字段==================");
    final Field[] fields = userClass.getFields();
    Arrays.stream(fields).forEach(System.out::println);
    //2.Field[] fields = clazz.getDeclaredFields() 获取任意权限所有字段
    System.out.println("=====================获取任意权限修饰的字段==================");
    Arrays.stream(userClass.getDeclaredMethods()).forEach(System.out::println);
    //3.Field field = clazz.getField(String fieldName）根据字段名获取public的指定字段
    System.out.println("=====================获取public修饰的指定字段的值==================");
    System.out.println(userClass.getField("age"));
    //4.Field field = clazz.getDeclaredField(String fieldName) 根据字段名获取任意访问权限的指定字段
    System.out.println("=====================获取private修饰的指定字段的值==================");
    System.out.println(userClass.getDeclaredField("name"));
    // 5.给public int age成员变量赋值，因为age是实例变量，所以需要创建一个User对象
    System.out.println("=====================给字段赋值==================");
    final Object instance = userClass.getConstructor().newInstance();
    final Field age = userClass.getField("age");
    age.set(instance, 17);
    System.out.println(age.get(instance));
    //6.给 public static String country;成员变量赋值	给某一个字段赋值：field.set(Object obj, Object value);
    System.out.println("=====================给static修饰的变量赋值==================");
    final Field country = userClass.getField("country");
    country.set(instance, "中国");
    System.out.println(country.get(instance));
  }
}

```

结果:

```java
=====================获取public修饰的字段==================
public static java.lang.String org.work_0812.classDemo.User.country
public int org.work_0812.classDemo.User.age
=====================获取任意权限修饰的字段==================
public java.lang.String org.work_0812.classDemo.User.getName()
public boolean org.work_0812.classDemo.User.equals(java.lang.Object)
public java.lang.String org.work_0812.classDemo.User.toString()
public int org.work_0812.classDemo.User.hashCode()
public void org.work_0812.classDemo.User.setName(java.lang.String)
public void org.work_0812.classDemo.User.test2(java.lang.String)
private void org.work_0812.classDemo.User.testPrivate()
public java.lang.String org.work_0812.classDemo.User.getPwd()
public static void org.work_0812.classDemo.User.testStatic()
public void org.work_0812.classDemo.User.setPwd(java.lang.String)
=====================获取public修饰的指定字段的值==================
public int org.work_0812.classDemo.User.age
=====================获取private修饰的指定字段的值==================
private java.lang.String org.work_0812.classDemo.User.name
=====================给字段赋值==================
17
=====================给static修饰的变量赋值==================
中国
```

可以看出在给字段赋值还是获取值的时候必须传入一个对象,也就是`newInstance`后的对象才可以

## 8.其他方法

1. String getName()  获取全限定类名（全限定，包含包名）	Class类中方法
2. String getSimpleName()   获取类名简称			Class类中方法
3. Package getPackage()   获取包名				Class类中方法
4. Annotation[] getAnnotations()  根据当前字节码获取所有的注解（类上的注解）

代码:

```java
public class ReflectTest4 {

	public static void main(String[] args) throws Exception {
		/*
		 * 1. 获取字节码文件(通过反射)
		 */
		// 1.1 Class clazz  = Class.forName(全限定路径名) (最多使用)默认就是调用下面的方法
		Class<?> clazz = Class.forName("cn.itsource.reflect.User");
		
		System.out.println(clazz == User.class); // 需要User类是已经设计好了的
		System.out.println(clazz == new User().getClass()); // 需要User类是已经设计好了的
		
		// String getName()  获取全限定类名（全限定，包含包名）	Class类中方法
		String name = clazz.getName();
		System.out.println(name);
		
		// String getSimpleName()   获取类名简称			Class类中方法
		String simpleName = clazz.getSimpleName();
		System.out.println(simpleName);
		
		// Package getPackage()   获取包名				Class类中方法
		Package package1 = clazz.getPackage();
		System.out.println(package1);
		
		// Annotation[] getAnnotations()  根据当前字节码获取所有的注解（类上的注解）
		Annotation[] annotations = clazz.getAnnotations();
		for (Annotation annotation : annotations) {
			System.out.println("注解：" + annotation);
		}
		
	}

}
```



## 7.反射优缺点和应用场景

**优点:**

1. 比较灵活，能够在运行时动态获取类的实例

**缺点:**

1. 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 Java 代码要慢很多。
2. 安全问题：反射机制破坏了封装性，因为通过反射可以获取并调用类的私有方法和字段

**应用场景:**

反射在我们实际编程中其实并不会直接大量的使用，但是实际上有很多设计都与反射机制有关，比如：

- 动态代理机制
- 使用 JDBC 连接数据库
- Spring / Hibernate 框架（实际上是因为使用了动态代理，所以才和反射机制有关)

比如JDBC连接数据库也使用了反射机制

​	我们经常在使用连接数据库的连接则必须走以下几步完成:

1. 通过 `Class.forName()` 加载数据库的驱动程序 （通过反射加载）
2. 通过 `DriverManager` 类连接数据库，参数包含数据库的连接地址、用户名、密码
3. 通过 `Connection` 接口接收连接
4. 关闭连接

```java
public static void main(String[] args) throws Exception {  
        Connection con = null; // 数据库的连接对象  
        // 1. 通过反射加载驱动程序
        Class.forName("com.mysql.jdbc.Driver"); 
        // 2. 连接数据库  
        con = DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/test","root","root"); 
        // 3. 关闭数据库连接
        con.close(); 
}
```

Spring框架

反射机制是 Java 框架设计的灵魂，框架的内部都已经封装好了，我们自己基本用不着写。典型的除了Hibernate 之外，还有 Spring 也用到了很多反射机制，最典型的就是 Spring 通过 xml 配置文件装载 Bean（创建对象），也就是 **Spring 的 IoC**，过程如下：

- 加载配置文件，获取 Spring 容器
- 使用反射机制，根据传入的字符串获得某个类的 Class 实例

```java
// 获取 Spring 的 IoC 容器，并根据 id 获取对象
public static void main(String[] args) {
    // 1.使用 ApplicationContext 接口加载配置文件，获取 spring 容器
    ApplicationContext ac = new ClassPathXmlApplicationContext("spring.xml");
    // 2. 使用反射机制，根据这个字符串获得某个类的 Class 实例
    IAccountService aService = (IAccountService) ac.getBean("accountServiceImpl");
    System.out.println(aService);
}
```

> 在String AOP由于使用了动态代理,所以也使用了反射机制,之所以说应用在Spring框架中的原因,是我们经常在配置文件或者些其他地方都是通过全限定类名然后获取字节码文件的,然后就能创建对象

## 8.注意

1. Class类中方法newInstance()：创建当前字节码对象（只能调用无参且是public修饰的构造方法）
2. Constructor类中方法newInstance(Object 实参);//可以创建任意访问权限的有参或者无参构造
3. 私有化方法、字段、构造方法都必须破坏封装才能使用：
   - public void setAccessible(boolean flag) true表示破坏封装，false是不破坏
   - 是哪个private修饰的方法、字段、构造方法需要执行，就需要用这个对象破坏哪一个的封装
4. 调用static方法、字段,因为是static修饰，所以不用对象调用，就传入null
5. 反射是在该类还没有设计好的时候，可以保证继续向后开发,只是保证功能开发完成，运行的话就必须时候整个项目开发完毕才可以,而项目真正运行的时候，肯定所有的项目中的类都已经设计完毕，这时候，就可以保证代码正常运行了
6. Class类 和它的实例的产生： Class的对象是已经存在的类型,所以不能够直接new一个Class对象出来，是通过Class类中的一个方法获取到的。
7. 同一种类型不管通过什么方式得到Class的实例都是相等的；一个类型的字节码对象只有一份，在元空间。

扩展:

1. 工具类:
   - https://www.jianshu.com/p/1ba3680c114c
   - https://blog.csdn.net/tianshan2010/article/details/103951346
2. java内省: 
   - https://www.cnblogs.com/H_Razor/archive/2011/02/28/1967178.html
   - https://blog.csdn.net/z714405489/article/details/84650307
   - https://www.cnblogs.com/avenwu/archive/2012/02/28/2372586.html【注解、内省】
   - https://www.cnblogs.com/alice-cj/p/11444723.html

# 注解

## 1.什么是注解:

说明:注解（Annotation），也叫元数据，标签，注释。注解叫注释的时候，容易和java的代码注释混淆，一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。

注解的另一个称呼注释，是给程序看的，大家可以将注解看成是一个标签，只不过这个标签有特殊含义，可能会执行特定的操作

注解和注释感觉是不是长得很相似,两者的本质就差不多,注释是给程序员看的,而注解呢就是给程序看的

**注解的简单分类:**

1. 自定义注解
2. JDK内置注解
3. 框架中的注解

**总结:**在程序中，可以把注解看成一种特殊的标记，一般是用来标记类，方法或者接口等，这些标记有一些特点，比如可以在编译的时候，（javac命令把java源文件编译成字节码文件class），类加载和运行的时候（使用java命令执行字节码文件的时候，类的生命周期开始，从加载到卸载）被读取到（一般是有专门的程序去读区这些注解，利用反射技术去解析注解，然后根据得到的信息做相应的处理）

> 对于注解，是有专门的程序去读取它，解析它，然后根据得到的消息去执行相应的操作。

**注解的本质:**本质上是一个接口!

```java
public @interface Main {}
```

此时就感觉普通的接口跟这个没啥区别,就多个@,我们就用反编译工具打开看看:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzFiODdmNDM3OTQxMjhlMTQ4YWQzMzc2ZDg2YjFlZGY2LmpwZw)

看到没，这里的Main直接就是interface定义，然后还继承了Annotation，这个足以说明，注解其实就是接口啊。

注解的图解:

![image-20210812184124754](https://gitee.com/miawei/pic-go-img/raw/master/imgs/image-20210812184124754.png)



## 2.如何定义注解:

语法:

```java
@注解的名称
@Override
    注解可以贴在方法,类,字段....
```

**注解**：由第三方程序提供支持，从而实现验证功能，例如:猪屁股上面合格的章，如果没有国家赋予意义，那么就相当于一个普通的标签而已。

## 3.作用:

1. 编写文档：事实上，在Java中我们可以通过注解去生成API文档，例如我们常见的参数值【@parameter】，返回值【@return】等，只有标识了这些，我们才能通过API文档更快速和有条理的查看到对应的相关信息
2. 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】(可以通过反射 看这个类有没有注解，有注解的时候，代码应该怎么写，没有注解的时候，应该怎么写)
3. 编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】(如果一个代码，添加一个注解，会帮我们检查是不是正确;)

注解的三大要素:

1. 需要有一个注解;
2. 使用这个注解(这个注解贴在什么地方)
3. 第三方程序为注解实现功能

> 比如Override，是Sun公司提供的，首先得有这么一个注解，然后会贴到需要贴的地方，最后有第三方法程序为注解实现功能

## 4.元注解

如果我们定义一个注解,试想一下这个注解可以标在哪些地方:类?接口?方法?,你看@Orride注解只能标在方法上,对吧,如果标在类上就会报错,所以对于这些最好有区分，也就是说，有些注解只能标记类，有些注解只能标记方法等，这样一来就需要对注解的作用域去进行限制。

这个怎么搞呢?答案就是元注解，那什么是元注解呢？

> 元注解就是标记注解的注解

### 4.1 基本语法:

对于注解，我们知道了如何去定义它，比如简单定义一个注解：

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzAwN2Y3M2U0ZDNkNzU5M2U5MDRkMGM1MjY3YTRkMWYzLmpwZw)

这很简单，我们继续去看，对于注解还可以定义属性：

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzU2NjM1OTRkMThjYzBjZmNmNTU2Mjc0N2U2NmNjMGQ2LmpwZw)

虽然这个属性看起来很像方法，但是人家就是属性，注解还是比较特殊的，那么现在我们来使用下这个注解：

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzI1Y2Y4ZWQ3OGU4OTNiNzIxNGQzZTI2ZjM1MTQyZTY0LmpwZw)

这个时候它会报错，告诉我们需要一个value值，其实也好理解，你的注解定义中定义的有一个value属性，那么你在使用的时候就需要把这个属性值给用上，那你说我可不可以不用，可以的，那定义注解属性的时候就需要给属性添加默认值，就是这样:

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kX2M0YjQxMjcyYWYxMWY0YTk4NWJmOTFkY2VkNDNlNTAxLmpwZw)

可以设置成一个空字符串也可以设置成具体的值。除此之外我们还可以设置多个属性值，像这样：

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzZjNmEzNDVkOThkNzk5ZTYzYTA0MmQ4ZjhiMDk3YWMxLmpwZw)

### 4.2 属性的类型

上面简单介绍了注解的属性，那么这些属性都是可以取哪些类型值呢？大致有如下这么多：

1. 基本数据类型
2. String
3. 枚举
4. Class
5. 注解类型
6. 数组（以上类型的一维数组）

比如最后的一个数组,举个例子:![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzYyMWZlYmU4MTNjZjYwNDdkZWMwZmRmOThlYTdkY2ZjLmpwZw)

### 4.3 注解如何起作用:

我们在使用一个注解的时候,除了简单的进行使用,却不知道它是如何起作用的.

**注解主要是被反射读取**

对于注解的读取，一般就是通过反射技术来实现，这里就有知识点了，对于反射而言，它只能读取内存中的字节码信息，然后还记得之前我们说的注解的作用域@Target吗？

![img](https://gitee.com/miawei/pic-go-img/raw/master/imgs/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kX2FjYmZlY2EyNTBiNDc1ZjExZmMwMGE4ODIyZGQ2M2FiLmpwZw)

对于RetentionPolicy.CLASS而言，这个就是指的字节码这一阶段，这个时候这个字节码文件是由Java源文件通过javac编译生成，这个时候class字节码文件其实还是在磁盘内，并没有进入内存中。

而反射只能取读取内存中的字节码信息，所以注解的保留策略也就是这个@Target只能是RUNTIME，也即运行的时候仍然可以读取

### 4.4 常用的元注解

1. @Target

   - 作用:用于描述注解的使用范围，也就是说使用了@Target去定义一个注解，那么可以决定定义好的注解能用在什么地方
   - 取值范围:
     - CONSTRUCTOR:用于描述构造器
     - FIELD:用于描述域
     - LOCAL_VARIABLE:用于描述局部变量
     - METHOD:用于描述方法
     - PACKAGE:用于描述包
     - PARAMETER:用于描述参数
     - TYPE:用于描述类、接口(包括注解类型) 或enum声明

2. @Retention

   - 作用:用于描述注解的生命周期，也就是说这个注解在什么范围内有效，注解的生命周期和三个阶段有关：源代码阶段、CLASS文件中有效、运行时有效，故其取值也就三个值，分别代表着三个阶段
   - 取值范围:
     - SOURCE:在源文件中有效（即源文件保留)
     - CLASS:在class文件中有效（即class保留）
     - RUNTIME:在运行时有效（即运行时保留）

3. @Documented

   - 作用:使用@Documented定义后的注解，在该注解使用后，如果导出API文档，会将该注解相关的信息可以被例如javadoc此类的工具文档化。
   - Documented是一个标记注解，没有成员。

4. @Inherited

   - 作用:使用@Inherited定义的注解具备继承性

     假设一个注解在定义时，使用了@Inherited，然后该注解在一个类上使用，如果这个类有子类，那么通过反射我们可以从类的子类上获取到同样的注解

总结:一个注解想要有意义，必须有第三方程序赋予注解意义

# 内省

## 1.内省是什么、实现方式：

1.  内省（Introspector）是[Java语言](https://www.baidu.com/s?wd=Java语言&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YknAf4rAmdm10LuymvP1fY0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPjnYnW63n1ns)对Bean类属性、事件的一种缺省处理方法。
2.  例如类A中有属性name,那我们可以通过getName,setName来得到其值或者设置新的值。
3.  通过getName/setName来访问name属性，这就是默认的规则。
4.  Java中提供了一套API用来访问某个属性的getter/setter方法，通过这些API可以使你不需要了解这个规则，
5.  这些API存放于包java.beans中。

```
Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性name,那我们可以通过getName,setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter/setter方法，通过这些API可以使你不需要了解这个规则（但你最好还是要搞清楚），这些API存放于包java.beans中。
```

步骤:

1.  一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，
2. 然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），
3. 通过这个属性描述器就可以获取某个属性对应的getter/setter方法， 
4. 然后我们就可以通过反射机制来调用这些方法。



## 2.内省和反射的区别:

反射式在运行状态把Java类中的各种成分映射成相应的Java类，可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态。 
内省机制是通过反射来实现的，BeanInfo用来暴露一个bean的属性、方法和事件，以后我们就可以操纵该JavaBean的属性

![这里写图片描述](https://gitee.com/miawei/pic-go-img/raw/master/imgs/20160422101525368)

## 3.代码演示

1. 内省(Introspector)是[Java](http://lib.csdn.net/base/java) 语言对Bean类属性、事件的一种缺省处理方法。例如类 A 中有属性 name, 那我们可以通过 getName,setName 来得到其值或者设置新的值。通过 getName/setName 来访问 name 属性，这就是默认的规则。 
2.  Java 中提供了一套 API 用来访问某个属性的 getter/setter 方法，通过这些 API 可以使你不需要了解这个规则（但你最好还是要搞清楚），这些 API 存放于包 java.beans 中。
3. 直接通过属性的描述器java.beans.PropertyDescriptor类，来访问属性的getter/setter 方法;

```java
public class Point {
    private Integer x;
    private Integer y;

    public Point(Integer x, Integer y) {
        super();
        this.x = x;
        this.y = y;
    }

   public Integer getX() {
       return x;
   }
   public void setX(Integer x) {
       this.x = x;
   }

   public Integer getY() {
       return y;
   }
   public void setY(Integer y) {
       this.y = y;
   }
  }
```

内省代码:

```java
import java.beans.PropertyDescriptor;
   import java.lang.reflect.Method;

   public class Reflect {

   public static void main(String[] args) throws Exception {
       Point point = new Point(2, 5);
       String proName = "x";
		
       //获取属性
       getProperty(point, proName);
       setProperty(point, proName);
   }

   private static void setProperty(Point point, String proName) throws Exception {
       PropertyDescriptor proDescriptor = new PropertyDescriptor(proName, Point.class);
       Method methodSetX = proDescriptor.getWriteMethod();
       methodSetX.invoke(point, 8);
       System.out.println(point.getX());// 8
   }

   private static void getProperty(Point point, String proName) throws Exception {
       //类似于反射的获取方法
       PropertyDescriptor proDescriptor = new PropertyDescriptor(proName, Point.class);
       Method methodGetX = proDescriptor.getReadMethod();
       Object objx = methodGetX.invoke(point);
       System.out.println(objx);// 2
   }
  }
```

内省访问JavaBean有两种方法：

1. 通过Introspector类获得Bean对象的 BeanInfo，然后通过 BeanInfo 来获取属性的描述器（ PropertyDescriptor ），通过这个属性描述器就可以获取某个属性对应的 getter/setter 方法，然后通过反射机制来调用这些方法。
2. 通过PropertyDescriptor来操作Bean对象

Student源码:

```java
public class Student {
     private String name;//字段
    
     public String getXxx(){//读方法
          return "xx";
     }
     public String setXxx(){//写方法
         return "xx";
     }
    public String getName() {
        return name;
    }
    public void setName(String name) {
         this.name = name;
    }
}
```

第一种方式:

```java
@Test
public void test() throws Exception{
     Student student = new Student();
    //1.通过Introspector来获取bean对象的beaninfo
    BeanInfo bif = Introspector.getBeanInfo(Student.class);
    
    //2.通过beaninfo来获得属性描述器(propertyDescriptor)
    PropertyDescriptor pds[] = bif.getPropertyDescriptors();
    
    //3.通过属性描述器来获得对应的get/set方法
    for(PropertyDescriptor pd:pds){
        //4.获得并输出字段的名字
         System.out.println(pd.getName());
        
        //5.获得并输出字段的类型
        System.out.println(pd.getPropertyType());
        
         if(pd.getName().equals("name")){
             //6.获得PropertyDescriptor对象的写方法
              Method md = pd.getWriteMethod();
             
             //7.执行写方法
              md.invoke(student, "Lou_Wazor");
         }
    }
    //8.输出所赋值字段的值
    System.out.println(student.getName());
}
//执行结果:
class
class java.lang.Class
name
class java.lang.String
xxx
class java.lang.String
Lou_Wazor
```

第二种方式:

```java
@Test
public void test01()throws Exception{
    Student st = new Student();
    //1.通过构造器来创建PropertyDescriptor对象
    PropertyDescriptor pd = new PropertyDescriptor("name", Student.class);
    
    //2.通过该对象来获得写方法
    Method method = pd.getWriteMethod();
    
    //3.执行写方法
     method.invoke(st, "Lou_Wazor");
    
    //4.输出对象字段的值
    System.out.println(st.getName());
    
    //5.通过对象获得读方法
    method = pd.getReadMethod();
    
    //6.执行读方法并定义变量接受其返回值并强制塑形
    String name = (String) method.invoke(st, null);
    
    //7.输出塑形后的值
    System.out.println(name); 
}
//执行结果:
Lou_Wazor
Lou_Wazor    
```

